<!DOCTYPE html>

<html lang="fr">

<!-- Début en-tête -->
<head>

  <title>Chapitre 13  circuits logiques et expressions booléennes </title>

  <meta charset="utf-8">

  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Bootstrap -->
<!-- Bootstrap -->
         <!-- Latest compiled and minified CSS -->
         <link rel="stylesheet" href="/assets/js/bootstrap-4.3.1-dist/css/bootstrap.min.css">
         <style>
          /* Make the image fully responsive */
          .carousel-inner img {
              width: 100%;
              height: 100%;
            }
        </style>
    <!-- jQuery library -->
    <script src="/assets/js/jquery.min.js"></script>

    <!-- Popper JS -->
<script src="/assets/js/popper.min.js"></script>

    <!-- Latest compiled JavaScript -->
    
<script src="/assets/js/bootstrap-4.3.1-dist/js/bootstrap.min.js"> </script> 



    <!-- Code Mirror coloration syntaxique du code -->

    <link rel="stylesheet" href="/assets/js/codemirror-5.47.0/theme/monokai.css">

    <script src="/assets/js/codemirror-5.47.0/lib/codemirror.js"></script>  
    <script src="/assets/js/codemirror-5.47.0/mode/python/python.js"></script>
	<script src="/assets/js/codemirror-5.47.0/mode/xml/xml.js"></script>
	<script src="/assets/js/codemirror-5.47.0/mode/javascript/javascript.js"></script>
	<script src="/assets/js/codemirror-5.47.0/mode/css/css.js"></script>
	<script src="/assets/js/codemirror-5.47.0/mode/htmlmixed/htmlmixed.js"></script>
	<script src="/assets/js/codemirror-5.47.0/addon/edit/matchbrackets.js"></script>


    
 
    
      <!-- Prism theme coy -->
      <script src="/assets/js/prism.js"></script>
    

    <!-- Feuille de style principale  -->
    <link rel="stylesheet" href="/assets/css/main.css">

</head>
<!-- Fin en-tête -->

<!-- Début corps -->    
<body class="bg-light">

    
    
<div class="container-fluid">
    
    <nav class="navbar navbar-expand-sm bg-info navbar-dark fixed-top">
        
  <a class="navbar-brand" href="https://lyceeduparc.fr/">
          <img src="/assets/images/logo-parc.png" alt="Logo" style="width:80px;">
    </a>
        
        
     <!-- Navbar text-->
  <span class="navbar-text">
    Première NSI 2020/2021
  </span>
        
        

</nav>
    


    <div class="jumbotron" style="margin-top:10%;">
      <h1>Chapitre 13  circuits logiques et expressions booléennes </h1>
                      
  <ul class="pagination">
    <li class="page-item"><a class="page-link" href="/">Progression</a></li>
    <li class="page-item"><a   class="page-link"  href="/outils">Outils</a></li>
    <li class="page-item"><a  class="page-link"  href="/ressources.html">Ressources</a></li>
    <li class="page-item"><a  class="page-link"  href="/qcm.html">QCM</a></li>
    <li class="page-item"><a  class="page-link"  href="/projets.html">Projets</a></li>
    <li class="page-item"><a  class="page-link"  href="/automatismes.html">Automatismes</a></li>
    <li class="page-item"><a  class="page-link"  href="/seances.html">Séances</a></li>
    <li class="page-item"><a  class="page-link"  href="https://github.com/parc-nsi/premiere-nsi">Github</a></li>
  </ul>
    
</div>
 
        
    <article>
      <p>Bienvenue sur le site de la classe de  Première NSI du <a href="https://lyceeduparc.fr/ldp/">lycée du Parc</a> à Lyon.</p>
        <p>Tous les documents sur ce site sont   placés sous licence 
          <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/"> 
            Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0).</a>
            </p>
            
        </article>
  

   


  <section>  
   <ul>
  <li><a href="#crédits">Crédits</a></li>
  <li><a href="#préambule">Préambule</a></li>
  <li><a href="#portes-logiques">Portes logiques</a>
    <ul>
      <li><a href="#le-transistor-porte-logique-de-base">Le transistor porte logique de base</a></li>
      <li><a href="#dautres-portes-logiques">D’autres portes logiques</a>
        <ul>
          <li><a href="#transistors-en-série-ou-en-parallèle">Transistors en série ou en parallèle</a></li>
          <li><a href="#portes-logiques-et-fonctions-logiques-élémentaires">Portes logiques et fonctions logiques élémentaires</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#fonctions-booléennes">Fonctions booléennes</a>
    <ul>
      <li><a href="#fonctions-booléennes-1">Fonctions booléennes</a></li>
      <li><a href="#qcm-types-e3c">QCM types E3C</a></li>
      <li><a href="#pour-aller-plus-loin-hors-programme-de-première-nsi">Pour aller plus loin (hors programme de première NSI)</a>
        <ul>
          <li><a href="#dresser-la-table-de-vérité-dune-fonction-booléenne">Dresser la table de vérité d’une fonction booléenne</a></li>
          <li><a href="#exprimer-une-fonction-booléenne-à-partir-de-sa-table-de-vérité">Exprimer une fonction booléenne à partir de sa table de vérité</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#circuits-combinatoires">Circuits combinatoires</a>
    <ul>
      <li><a href="#définition">Définition</a></li>
      <li><a href="#décodeur-avec-2-bits-dentrées">Décodeur avec 2 bits d’entrées</a></li>
      <li><a href="#demi-additionneur-et-additionneur-1-bit">Demi-additionneur et additionneur 1 bit</a></li>
    </ul>
  </li>
  <li><a href="#opérations-bit-à-bit-en-python-hors-programme-de-première-nsi">Opérations bit à bit en <code class="language-plaintext highlighter-rouge">Python</code> (hors programme de première NSI)</a>
    base](#le-transistor-porte-logique-de-base)
    <ul>
      <li><a href="#dautres-portes-logiques">D’autres portes logiques</a>
        <ul>
          <li><a href="#transistors-en-série-ou-en-parallèle">Transistors en série ou en
parallèle</a></li>
          <li><a href="#portes-logiques-et-fonctions-logiques-élémentaires">Portes logiques et fonctions logiques
élémentaires</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#fonctions-booléennes">Fonctions booléennes</a>
    <ul>
      <li><a href="#fonctions-booléennes-1">Fonctions booléennes</a></li>
      <li><a href="#qcm-types-e3c">QCM types E3C</a></li>
      <li><a href="#pour-aller-plus-loin-hors-programme-de-première-nsi">Pour aller plus loin (hors programme de première
NSI)</a>
        <ul>
          <li><a href="#dresser-la-table-de-vérité-dune-fonction-booléenne">Dresser la table de vérité d’une fonction
booléenne</a></li>
          <li><a href="#exprimer-une-fonction-booléenne-à-partir-de-sa-table-de-vérité">Exprimer une fonction booléenne à partir de sa table de
vérité</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#circuits-combinatoires">Circuits combinatoires</a>
    <ul>
      <li><a href="#définition">Définition</a></li>
      <li><a href="#décodeur-avec-2-bits-dentrées">Décodeur avec 2 bits d’entrées</a></li>
      <li><a href="#demi-additionneur-et-additionneur-1-bit">Demi-additionneur et additionneur 1
bit</a></li>
    </ul>
  </li>
  <li><a href="#opérations-bit-à-bit-en-python-hors-programme-de-première-nsi">Opérations bit à bit en <code class="language-plaintext highlighter-rouge">Python</code> (hors programme de première
NSI)</a></li>
</ul>

<h1 id="crédits">Crédits</h1>

<p><em>Ce cours est largement inspiré du chapitre 22 du manuel NSI de la
collection Tortue chez Ellipsen auteurs : Ballabonski, Conchon,
Filliatre, N’Guyen.</em></p>

<h1 id="préambule">Préambule</h1>

<p>Les circuits d’un ordinateur manipulent uniquement des 0 ou des 1
représentés en interne par des tensions hautes ou basses. Les premiers
ordinateurs construits dans la période 1945-1950 sont basés sur une
technologie de tube à vide ou tube électrique. En 1947, aux laboratoires
Bell, <a href="https://fr.wikipedia.org/wiki/Transistor">Shockley, Bardeen et
Brattain</a> inventent le
<strong>transistor</strong> au <em>germanium</em> un petit composant électronique qui se
comporte comme un interrupteur. Les transistors, plus petits et
dissipant moins de chaleur, vont supplanter les tubes électriques : en
1954 le <em>germanium</em> est remplacé par le <em>silicium</em>, en 1955 apparaissent
les premiers ordinateurs entièrement transistorisés, en 1960 le
transistor à effet de champ permet l’intégration de dizaines composants
dans un centimètre carré. Les transistors sont ensuite directement
gravés dans une plaque de <em>silicium</em> constituant un <strong>cicrcuit
intégré</strong>. En 1965 Gordon Moore futur directeur d’Intel énonce la <a href="https://fr.wikipedia.org/wiki/Loi_de_Moore">loi
empirique</a> portant son nom
qui fixe une feuille de route à l’industrie des mircroprocesseurs : le
doublement de la densité d’intégration des transistors tous les deux
ans. Cette loi s’est vérifiée jusqu’à présent avec une finesse de
gravure d’environ 5 nanomètres en 2020. Le
<a href="https://en.wikipedia.org/wiki/Moore%27s_law#/media/File:Moore's_Law_Transistor_Count_1971-2018.png">graphique</a>
ci-dessous représente l’évolution du nombre de transistors par circuit
intégré.</p>

<p><img src="images/640px-Moores_Law_Transistor_Count_1971-2018.png" alt="Loi de Moore Source :
Wikipedia" /></p>

<h1 id="portes-logiques">Portes logiques</h1>

<h2 id="le-transistor-porte-logique-de-base">Le transistor porte logique de base</h2>

<p><strong>Définition 1</strong></p>

<p>Un <strong>transistor</strong> possède trois broches : la grille, la sortie (ou
drain) et la source soumis à des états de tension haute ou basse qu’on
peut assimiler aux valeurs binaires 1 et 0 d’un <strong>bit</strong>. Si la tension
appliquée sur la grille est haute (bit à 1) alors le transitor laisse
passer le courant entre la source d’énergie et la sortie et cette
dernière passe à l’état de tension basse (bit à 0), sinon la sortie
reste en tension haute (bit 1).</p>

<p>Une <strong>fonction logique</strong> prend un ou plusieurs bits en entrée et
retourne un ou plusieurs bits en sortie. Une <strong>porte logique</strong> est un
circuit électronique représentant une <strong>fonction logique</strong>.</p>

<p>Une <strong>table logique</strong> représente les sorties produites par une fonction
logique pour toutes les entrées possibles.</p>

<p>Un transistor représente une fonction logique dont le bit d’entrée est
l’état de tension de la grille et le bit de sortie, l’état de tension
de la sortie. La <strong>table logique</strong> (table 1) associée est celle du <strong>NON
logique</strong> ou <strong>Inverseur</strong>.</p>

<p>Fichier de test <a href="http://www.cburch.com/logisim/">Logisim</a> :
<a href="circuits_logisim/transistor.circ">transistor.circ</a>.</p>

<p><img src="images/transistor.png" alt="Transistor" /></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">A</th>
      <th>B = NON(A)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td>1</td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p><strong>Table logique d’une porte NON</strong></p>

<p><strong>Il existe deux conventions de représentation symbolique des portes
logiques, une européenne et une américaine.</strong></p>

<p><img src="images/porte_not_european.png" alt="porte NOT européeenne" /><br />
&amp; <img src="images/porte_not_american.png" alt="porte NOT américaine" /></p>

<p><a href="videos/transistor-definition1.mp4">Tutoriel video Logisim : le
transistor</a></p>

<h2 id="dautres-portes-logiques">D’autres portes logiques</h2>

<h3 id="transistors-en-série-ou-en-parallèle">Transistors en série ou en parallèle</h3>

<p><strong>Exercice 1</strong></p>

<p>On donne ci-dessous les représentations de deux portes logiques :</p>

<ul>
  <li>La <strong>porte NAND</strong> constituée de deux transistors en série</li>
  <li>La <strong>porte NOR</strong> constituée de deux transistors en parallèle</li>
</ul>

<p>Chacune de ces portes logiques comportent deux bits d’entrée : A pour la
grille du transistor 1 et B pour la grille du transistor 2 et un bit de
sortie.</p>

<p>Compléter leurs tables logiques.</p>

<p>Vérifier avec <a href="http://www.cburch.com/logisim/">Logisim</a> et les fichiers
<a href="circuits_logisim/porte_NAND.circ">porte_NAND.circ</a> et
<a href="circuits_logisim/porte_NOR.circ">porte_NOR.circ</a>.</p>

<p><a href="videos/porteNAND.mp4">Tutoriel video Logisim : porte NAND</a></p>

<p><a href="videos/porteNOR.mp4">Tutoriel video Logisim : porte NOR</a></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">A</th>
      <th>B</th>
      <th>NAND(A, B)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td>0</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">0</td>
      <td>1</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>0</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>1</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th style="text-align: center">A</th>
      <th>B</th>
      <th>NOR(A, B)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td>0</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">0</td>
      <td>1</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>0</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>1</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p><img src="images/porte_nand.png" alt="Porte NAND" /><br />
&amp; <img src="images/porte_nor.png" alt="Porte NOR" /></p>

<p><strong>Voici les représentations symboliques des portes logiques NAND et NOR
:</strong></p>

<p><img src="images/porte_nand_european.png" alt="Porte NAND européenne" /><br />
&amp; <img src="images/porte_nand_american.png" alt="Porte NAND américaine" /></p>

<p><img src="images/porte_nor_european.png" alt="Porte NOR européenne" /><br />
&amp; <img src="images/porte_nor_american.png" alt="Porte NOR américaine" /></p>

<h3 id="portes-logiques-et-fonctions-logiques-élémentaires">Portes logiques et fonctions logiques élémentaires</h3>

<p><strong>Exercice 2</strong></p>

<p>Fichier de test <a href="http://www.cburch.com/logisim/">Logisim</a> :
<a href="circuits_logisim/exercice2.circ">exercice2.circ</a>.</p>

<ol>
  <li>Compléter la table logique de la porte logique représentée par le
circuit ci-dessous. Quelle porte logique peut-on ainsi représenter ?</li>
</ol>

<p><img src="images/porte_not_with_nor.png" alt="Porte NOT" /></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">A</th>
      <th>B = f(A)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<ol>
  <li>Compléter la table logique de la porte logique représentée par le
circuit ci-dessous. Quelle fonction logique correspond à cette porte
logique ?</li>
</ol>

<p><img src="images/porte_and_with_nor.png" alt="Porte AND" /></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">A</th>
      <th>B</th>
      <th>C = g(A, B)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td>0</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">0</td>
      <td>1</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>0</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>1</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p><a href="videos/exercice2.mp4">Tutoriel video Logisim : exercice 2</a></p>

<p><strong>Exercice 3</strong></p>

<p>Fichier de test <a href="http://www.cburch.com/logisim/">Logisim</a> :
<a href="circuits_logisim/exercice3.circ">exercice3.circ</a>.</p>

<ol>
  <li>Compléter la table logique de la porte logique représentée par le
circuit ci-dessous. Quelle porte logique peut-on ainsi représenter ?</li>
</ol>

<p><img src="images/porte_not_with_nand.png" alt="Porte NOT" /></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">A</th>
      <th>B = f(A)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<ol>
  <li>Compléter la table logique de la porte logique représentée par le
circuit ci-dessous. Quelle fonction logique correspond à cette porte
logique ?</li>
</ol>

<p><img src="images/porte_or_with_nand.png" alt="Porte OR" /></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">A</th>
      <th>B</th>
      <th>C = g(A, B)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td>0</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">0</td>
      <td>1</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>0</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>1</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p><a href="videos/exercice3.mp4">Tutoriel video Logisim : exercice 3</a></p>

<p><strong>Voici les représentations symboliques des portes logiques <code class="language-plaintext highlighter-rouge">AND</code> et
<code class="language-plaintext highlighter-rouge">OR</code> :</strong></p>

<p><img src="images/porte_and_european.png" alt="Porte AND européenne" /><br />
&amp; <img src="images/porte_and_american.png" alt="Porte AND américaine" /></p>

<p><img src="images/porte_or_european.png" alt="Porte OR européenne" /><br />
&amp; <img src="images/porte_or_american.png" alt="Porte OR américaine" /></p>

<p><strong>Exercice 4</strong></p>

<ol>
  <li>Construire un circuit représentant une porte <code class="language-plaintext highlighter-rouge">OR</code> uniquement avec
des portes <code class="language-plaintext highlighter-rouge">NOR</code>.</li>
  <li>Construire un circuit représentant une porte <code class="language-plaintext highlighter-rouge">AND</code> uniquement avec
des portes <code class="language-plaintext highlighter-rouge">NAND</code>.</li>
</ol>

<p>Ainsi chacune des portes, <code class="language-plaintext highlighter-rouge">NAND</code> ou <code class="language-plaintext highlighter-rouge">NOR</code> permet de construire les
portes <code class="language-plaintext highlighter-rouge">NOT</code>, <code class="language-plaintext highlighter-rouge">OR</code>, <code class="language-plaintext highlighter-rouge">AND</code>. Toute porte logique pouvant s’exprimer à
l’aide de ces trois portes, les portes <code class="language-plaintext highlighter-rouge">NAND</code> et <code class="language-plaintext highlighter-rouge">NOR</code> sont dites
<em>universelles</em>.</p>

<p><a href="videos/exercice4.mp4">Tutoriel video Logisim : exercice 4</a></p>

<h1 id="fonctions-booléennes">Fonctions booléennes</h1>

<h2 id="fonctions-booléennes-1">Fonctions booléennes</h2>

<p><strong>Définition 2</strong></p>

<ul>
  <li>Un <strong>booléen</strong> est un type de données pouvant prendre deux valeurs
<code class="language-plaintext highlighter-rouge">True</code> (Vrai) ou <code class="language-plaintext highlighter-rouge">False</code> (Faux) qu’on représente numériquement par
un <strong>bit</strong> de valeur <img src="https://latex.codecogs.com/png.latex?1" alt="1" title="1" /> pour <code class="language-plaintext highlighter-rouge">True</code> ou <img src="https://latex.codecogs.com/png.latex?0" alt="0" title="0" />
pour <code class="language-plaintext highlighter-rouge">False</code>. Electroniquement, les valeurs 1 et 0 se traduisent
respectivement par des tensions haute ou basse.</li>
  <li>Une <strong>fonction booléenne</strong>
<img src="https://latex.codecogs.com/png.latex?f" alt="f" title="f" /> associe un booléen
à un ou plusieurs booléens.</li>
  <li>Une <strong>fonction booléenne</strong> avec
<img src="https://latex.codecogs.com/png.latex?n" alt="n" title="n" /> arguments est
définie sur un ensemble
<img src="https://latex.codecogs.com/png.latex?%5C%7B0%3B1%5C%7D%5En" alt="\{0;1\}^n" title="\\{0;1\\}^n" /> à <img src="https://latex.codecogs.com/png.latex?2%5En" alt="2^n" title="2^n" /> valeurs et prend ses valeurs dans
<img src="https://latex.codecogs.com/png.latex?%5C%7B0%3B1%5C%7D" alt="\{0;1\}" title="\\{0;1\\}" /> qui a <img src="https://latex.codecogs.com/png.latex?2" alt="2" title="2" />
éléments. On peut recenser les
<img src="https://latex.codecogs.com/png.latex?2%5En" alt="2^n" title="2^n" /> évaluations
d’une fonction booléenne à
<img src="https://latex.codecogs.com/png.latex?n" alt="n" title="n" /> arguments dans une
<strong>table de vérité</strong> qui la définit entièrement. Il existe
<img src="https://latex.codecogs.com/png.latex?2%5E%7B2%5En%7D" alt="2^{2^n}" title="2^{2^n}" /> fonctions booléennes à
<img src="https://latex.codecogs.com/png.latex?n" alt="n" title="n" /> arguments.</li>
  <li>Une <strong>porte logique</strong> est la représentation sous forme de circuit
d’une fonction booléenne et sa <strong>table logique</strong> est la <strong>table de
vérité</strong> de cette fonction.</li>
</ul>

<p><strong>Exercice 5</strong></p>

<ol>
  <li>Compléter la fonction <code class="language-plaintext highlighter-rouge">Python</code> ci-dessous pour qu’elle affiche la
table de vérité d’une fonction booléenne à deux entrées. Expliquer
le rôle de la fonction <code class="language-plaintext highlighter-rouge">int</code>.</li>
</ol>

<!-- end list -->

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">table_verite_2bits</span><span class="p">(</span><span class="n">fonction</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'|{:^10}|{:^10}|{:^15}|'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="s">'a'</span><span class="p">,</span><span class="s">'b'</span><span class="p">,</span><span class="n">fonction</span><span class="p">.</span><span class="n">__name__</span><span class="o">+</span><span class="s">'(a,b)'</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">.............:</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="p">.............:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">'|{:^10}|{:^10}|{:^15}|'</span><span class="p">.</span><span class="nb">format</span><span class="p">(......,</span> <span class="p">......,</span> 
            <span class="nb">int</span><span class="p">(</span><span class="n">fonction</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="n">a</span><span class="p">),</span><span class="nb">bool</span><span class="p">(</span><span class="n">b</span><span class="p">)))))</span>
</code></pre></div></div>

<ol>
  <li>Vérifier que les tables de vérité affichées pour les fonctions
<code class="language-plaintext highlighter-rouge">bool.__or__</code>, <code class="language-plaintext highlighter-rouge">bool.__and__</code> et <code class="language-plaintext highlighter-rouge">bool.__not__</code> sont correctes.</li>
</ol>

<!-- end list -->

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">In</span> <span class="p">[</span><span class="mi">4</span><span class="p">]:</span> <span class="n">table_verite_2bits</span><span class="p">(</span><span class="nb">bool</span><span class="p">.</span><span class="n">__or__</span><span class="p">)</span>                                                                                                                                           
<span class="o">|</span>    <span class="n">a</span>     <span class="o">|</span>    <span class="n">b</span>     <span class="o">|</span>  <span class="n">__or__</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>  <span class="o">|</span>
<span class="o">|</span>    <span class="mi">1</span>     <span class="o">|</span>    <span class="mi">1</span>     <span class="o">|</span>       <span class="mi">1</span>       <span class="o">|</span>
<span class="o">|</span>    <span class="mi">1</span>     <span class="o">|</span>    <span class="mi">0</span>     <span class="o">|</span>       <span class="mi">1</span>       <span class="o">|</span>
<span class="o">|</span>    <span class="mi">0</span>     <span class="o">|</span>    <span class="mi">1</span>     <span class="o">|</span>       <span class="mi">1</span>       <span class="o">|</span>
<span class="o">|</span>    <span class="mi">0</span>     <span class="o">|</span>    <span class="mi">0</span>     <span class="o">|</span>       <span class="mi">0</span>       <span class="o">|</span>
</code></pre></div></div>

<p><a href="videos/exercice5.mp4">Tutoriel video : exercice 5</a></p>

<p><strong>Propriété 1</strong></p>

<p>On peut exprimer toute fonction booléenne à l’aide de trois fonctions
booléennes élémentaires :</p>

<ul>
  <li>La <em>négation</em> de <img src="https://latex.codecogs.com/png.latex?x" alt="x" title="x" />
est une fonction à 1 bit d’entrée (unaire) notée <img src="https://latex.codecogs.com/png.latex?%5Cneg%20x" alt="\neg
x" title="\\neg x" /> ou
<img src="https://latex.codecogs.com/png.latex?%5Coverline%7Bx%7D" alt="\overline{x}" title="\\overline{x}" />.<br />
Si <code class="language-plaintext highlighter-rouge">x</code> est un booléen, sa <em>négation</em> est <code class="language-plaintext highlighter-rouge">not x</code> en <code class="language-plaintext highlighter-rouge">Python</code>.</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="https://latex.codecogs.com/png.latex?x" alt="x" title="x" /></th>
      <th><img src="https://latex.codecogs.com/png.latex?%5Cneg%20x" alt="\neg x" title="\\neg x" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<ul>
  <li>La <em>conjonction</em> de <img src="https://latex.codecogs.com/png.latex?x" alt="x" title="x" />
et <img src="https://latex.codecogs.com/png.latex?y" alt="y" title="y" /> est une fonction
à 2 bits d’entrée (binaire) notée <img src="https://latex.codecogs.com/png.latex?x%20%5Cwedge%20y" alt="x \wedge
y" title="x \\wedge y" /> ou <img src="https://latex.codecogs.com/png.latex?x%20.%20y" alt="x .
y" title="x . y" />.<br />
Si <code class="language-plaintext highlighter-rouge">x</code> et <code class="language-plaintext highlighter-rouge">y</code> sont des booléens, leur <em>conjonction</em> est <code class="language-plaintext highlighter-rouge">x and y</code> en
<code class="language-plaintext highlighter-rouge">Python</code>.</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="https://latex.codecogs.com/png.latex?x" alt="x" title="x" /></th>
      <th><img src="https://latex.codecogs.com/png.latex?y" alt="y" title="y" /></th>
      <th><img src="https://latex.codecogs.com/png.latex?x%20%5Cwedge%20y" alt="x \wedge y" title="x \\wedge y" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td>0</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">0</td>
      <td>1</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>0</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>1</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<ul>
  <li>La <em>disconjonction</em> de <img src="https://latex.codecogs.com/png.latex?x" alt="x" title="x" /> et <img src="https://latex.codecogs.com/png.latex?y" alt="y" title="y" /> est une
fonction à 2 bits d’entrée (binaire) notée <img src="https://latex.codecogs.com/png.latex?x%20%5Cvee%20y" alt="x \vee
y" title="x \\vee y" />
ou <img src="https://latex.codecogs.com/png.latex?x%20%2B%20y" alt="x + y" title="x + y" />.<br />
Si <code class="language-plaintext highlighter-rouge">x</code> et <code class="language-plaintext highlighter-rouge">y</code> sont des booléens, leur <em>disjonction</em> est <code class="language-plaintext highlighter-rouge">x or y</code> en
<code class="language-plaintext highlighter-rouge">Python</code>.</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="https://latex.codecogs.com/png.latex?x" alt="x" title="x" /></th>
      <th><img src="https://latex.codecogs.com/png.latex?y" alt="y" title="y" /></th>
      <th><img src="https://latex.codecogs.com/png.latex?x%20%5Cvee%20y" alt="x \vee y" title="x \\vee y" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td>0</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">0</td>
      <td>1</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>0</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>1</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p><strong>Propriété 2</strong></p>

<ol>
  <li>Les fonctions booléennes élémentaires respectent un certain nombre
de règles qui permettent de simplifier les expressions booléennes
complexes :</li>
</ol>

<!-- end list -->

<ul>
  <li><em>opérateur involutif</em> : <img src="https://latex.codecogs.com/png.latex?%5Cneg%28%5Cneg%20x%29%20%3D%20x" alt="\neg(\neg x) =
x" title="\\neg(\\neg x) = x" /> et
<img src="https://latex.codecogs.com/png.latex?%5Coverline%7B%5Coverline%7Bx%7D%7D%3Dx" alt="\overline{\overline{x}}=x" title="\\overline{\\overline{x}}=x" /></li>
  <li><em>élément neutre</em> : <img src="https://latex.codecogs.com/png.latex?1%20%5Cwedge%20x%20%3D%20x" alt="1 \wedge x =
x" title="1 \\wedge x = x" /> et <img src="https://latex.codecogs.com/png.latex?1%20.%20x%20%3Dx" alt="1 . x
=x" title="1 . x =x" /> ou <img src="https://latex.codecogs.com/png.latex?0%20%5Cvee%20x%20%3D%20x" alt="0 \vee x =
x" title="0 \\vee x = x" /> et <img src="https://latex.codecogs.com/png.latex?0%20%2B%20x%20%3Dx" alt="0 + x
=x" title="0 + x =x" /></li>
  <li><em>élément absorbant</em> : <img src="https://latex.codecogs.com/png.latex?0%20%5Cwedge%20x%20%3D%200" alt="0 \wedge x
= 0" title="0 \\wedge x = 0" /> et <img src="https://latex.codecogs.com/png.latex?0%20.%20x%20%3D0" alt="0 . x
=0" title="0 . x =0" /> ou <img src="https://latex.codecogs.com/png.latex?1%20%5Cvee%20x%20%3D%20x" alt="1 \vee x =
x" title="1 \\vee x = x" /> et <img src="https://latex.codecogs.com/png.latex?1%20%2B%20x%20%3D1" alt="1 + x
=1" title="1 + x =1" /></li>
  <li><em>idempotence</em> : <img src="https://latex.codecogs.com/png.latex?x%20%5Cwedge%20x%20%3D%20x" alt="x \wedge x =
x" title="x \\wedge x = x" /> et <img src="https://latex.codecogs.com/png.latex?x%20.%20x%20%3Dx" alt="x . x
=x" title="x . x =x" /> ou <img src="https://latex.codecogs.com/png.latex?x%20%5Cvee%20x%20%3D%20x" alt="x \vee x =
x" title="x \\vee x = x" /> et <img src="https://latex.codecogs.com/png.latex?x%20%2B%20x%20%3Dx" alt="x + x
=x" title="x + x =x" /></li>
  <li><em>complément</em> : <img src="https://latex.codecogs.com/png.latex?x%20%5Cwedge%20%28%5Cneg%20x%29%20%3D%200" alt="x \wedge (\neg x)
= 0" title="x \\wedge (\\neg x) = 0" /> et <img src="https://latex.codecogs.com/png.latex?x%20.%20%28%5Coverline%7Bx%7D%29%20%3D0" alt="x . (\overline{x})
=0" title="x . (\\overline{x}) =0" /> ou <img src="https://latex.codecogs.com/png.latex?x%20%5Cvee%20%28%5Cneg%20x%29%20%3D%201" alt="x \vee (\neg x)
= 1" title="x \\vee (\\neg x) = 1" /> et <img src="https://latex.codecogs.com/png.latex?x%20%2B%20%5Coverline%7Bx%7D%20%3D1" alt="x + \overline{x}
=1" title="x + \\overline{x} =1" /></li>
  <li><em>commutativité</em> : <img src="https://latex.codecogs.com/png.latex?x%20%5Cwedge%20y%20%3D%20y%20%5Cwedge%20x" alt="x \wedge y = y \wedge
x" title="x \\wedge y = y \\wedge x" /> et <img src="https://latex.codecogs.com/png.latex?x%20.%20y%20%3D%20y%20.%20x" alt="x . y = y .
x" title="x . y = y . x" /> ou <img src="https://latex.codecogs.com/png.latex?x%20%5Cvee%20y%20%3D%20y%20%5Cvee%20x" alt="x \vee y = y \vee
x" title="x \\vee y = y \\vee x" /> et <img src="https://latex.codecogs.com/png.latex?x%20%2B%20y%20%3D%20y%20%2B%20x" alt="x + y = y +
x" title="x + y = y + x" /></li>
  <li><em>associativité</em> : <img src="https://latex.codecogs.com/png.latex?x%20%5Cwedge%20%28%20y%20%5Cwedge%20z%29%20%3D%20%28x%20%5Cwedge%20y%29%20%5Cwedge%20z" alt="x \wedge ( y \wedge z) = (x \wedge y) \wedge
z" title="x \\wedge ( y \\wedge z) = (x \\wedge y) \\wedge z" /> et <img src="https://latex.codecogs.com/png.latex?x%20.%20%28y%20.%20z%29%20%3D%20%28x%20.%20y%29%20.%20z" alt="x . (y .
z) = (x . y) .
z" title="x . (y . z) = (x . y) . z" /> ou <img src="https://latex.codecogs.com/png.latex?x%20%5Cvee%20%28%20y%20%5Cvee%20z%29%20%3D%20%28x%20%5Cvee%20y%29%20%5Cvee%20z" alt="x \vee ( y \vee z) = (x \vee y)
\vee
z" title="x \\vee ( y \\vee z) = (x \\vee y) \\vee z" /> et ![x + (y + z) = (x
    <ul>
      <li>y) +
z](https://latex.codecogs.com/png.latex?x%20%2B%20%28y%20%2B%20z%29%20%3D%20%28x%20%2B%20y%29%20%2B%20z
“x + (y + z) = (x + y) + z”)</li>
    </ul>
  </li>
  <li><em>distributivité</em> : <img src="https://latex.codecogs.com/png.latex?x%20%5Cwedge%20%28%20y%20%5Cvee%20z%29%20%3D%20%28x%20%5Cwedge%20y%29%20%5Cvee%20%28x%20%5Cwedge%20z%29" alt="x \wedge ( y \vee z) = (x \wedge y) \vee (x
\wedge
z)" title="x \\wedge ( y \\vee z) = (x \\wedge y) \\vee (x \\wedge z)" /> et <img src="https://latex.codecogs.com/png.latex?x%20.%20%28y%20%2B%20z%29%20%3D%20x%20.%20y%20%2B%20x%20.%20z" alt="x
. (y + z) = x . y + x .
z" title="x . (y + z) = x . y + x . z" /> ou <img src="https://latex.codecogs.com/png.latex?x%20%5Cvee%20%28%20y%20%5Cwedge%20z%29%20%3D%20%28x%20%5Cvee%20y%29%20%5Cwedge%20%28x%20%5Cvee%20z%29" alt="x \vee ( y \wedge z) = (x
\vee y) \wedge (x \vee
z)" title="x \\vee ( y \\wedge z) = (x \\vee y) \\wedge (x \\vee z)" /> et <img src="https://latex.codecogs.com/png.latex?x%20%2B%20%28y%20.%20z%29%20%3D%20%28x%20%2B%20y%29%20.%20%28x%20%2B%20z%29" alt="x +
(y . z) = (x + y) . (x +
z)" title="x + (y . z) = (x + y) . (x + z)" /></li>
  <li><em>loi de Morgan</em> : <img src="https://latex.codecogs.com/png.latex?%5Cneg%28x%20%5Cwedge%20y%29%20%3D%20%5Cneg%20x%20%5Cvee%20%5Cneg%20y" alt="\neg(x \wedge y) = \neg x \vee \neg
y" title="\\neg(x \\wedge y) = \\neg x \\vee \\neg y" /> et <img src="https://latex.codecogs.com/png.latex?%5Coverline%7Bx%20.%20y%7D%20%3D%20%5Coverline%7Bx%7D%20%2B%20%5Coverline%7By%7D" alt="\overline{x . y}
= \overline{x} +
\overline{y}" title="\\overline{x . y} = \\overline{x} + \\overline{y}" /> ou <img src="https://latex.codecogs.com/png.latex?%5Cneg%28x%20%5Cvee%20y%29%20%3D%20%5Cneg%20x%20%5Cwedge%20%5Cneg%20y" alt="\neg(x
\vee y) = \neg x \wedge \neg
y" title="\\neg(x \\vee y) = \\neg x \\wedge \\neg y" /> et <img src="https://latex.codecogs.com/png.latex?%5Coverline%7Bx%20%2B%20y%7D%20%3D%20%5Coverline%7Bx%7D%20.%20%5Coverline%7By%7D" alt="\overline{x + y}
= \overline{x} .
\overline{y}" title="\\overline{x + y} = \\overline{x} . \\overline{y}" /></li>
</ul>

<!-- end list -->

<ol>
  <li>Les fonctions booléennes élémentaire respectent des règles de
priorité : la <em>négation</em> est prioritaire sur la <em>conjonction</em> qui
est prioritaire sur la <em>disjonction</em>.<br />
<strong>Il est recommandé de mettre des parenthèses plutôt que d’appliquer
les règles de priorité dans l’écriture des expressions booléennes.</strong></li>
</ol>

<h2 id="qcm-types-e3c">QCM types E3C</h2>

<p><strong>Exercice 6</strong></p>

<ol>
  <li>Parmi les quatre expressions suivantes, laquelle s’évalue en True ?</li>
</ol>

<!-- end list -->

<ul>
  <li>
    <p><strong>Réponse A :</strong> <code class="language-plaintext highlighter-rouge">False and (True and False)</code></p>
  </li>
  <li>
    <p><strong>Réponse B :</strong> <code class="language-plaintext highlighter-rouge">False or (True and False)</code></p>
  </li>
  <li>
    <p><strong>Réponse B :</strong> <code class="language-plaintext highlighter-rouge">True and (True and False)</code></p>
  </li>
  <li>
    <p><strong>Réponse C :</strong> <code class="language-plaintext highlighter-rouge">True or (True and False)</code></p>
  </li>
</ul>

<!-- end list -->

<ol>
  <li>Sachant que l’expression <code class="language-plaintext highlighter-rouge">not(a or b)</code> a la valeur <code class="language-plaintext highlighter-rouge">True</code>, quelles
peuvent être les valeurs des variables booléennes a et b ?</li>
</ol>

<!-- end list -->

<ul>
  <li><strong>Réponse A :</strong> <code class="language-plaintext highlighter-rouge">True</code> et <code class="language-plaintext highlighter-rouge">True</code></li>
  <li><strong>Réponse B :</strong> <code class="language-plaintext highlighter-rouge">False</code> et <code class="language-plaintext highlighter-rouge">True</code></li>
  <li><strong>Réponse C :</strong> <code class="language-plaintext highlighter-rouge">True</code> et <code class="language-plaintext highlighter-rouge">False</code></li>
  <li><strong>Réponse D :</strong> <code class="language-plaintext highlighter-rouge">False</code> et <code class="language-plaintext highlighter-rouge">False</code></li>
</ul>

<!-- end list -->

<ol>
  <li>Pour quelles valeurs booléennes des variables <code class="language-plaintext highlighter-rouge">a, b</code> et <code class="language-plaintext highlighter-rouge">c</code>
l’expression <code class="language-plaintext highlighter-rouge">(a or b) and (not c)</code> a-t-elle pour valeur <code class="language-plaintext highlighter-rouge">True</code></li>
</ol>

<!-- end list -->

<ul>
  <li><strong>Réponse A :</strong> <code class="language-plaintext highlighter-rouge">a = True b = False c = True</code></li>
  <li><strong>Réponse B :</strong> <code class="language-plaintext highlighter-rouge">a = True b = False c = False</code></li>
  <li><strong>Réponse C :</strong> <code class="language-plaintext highlighter-rouge">a = False b = False c = True</code></li>
  <li><strong>Réponse D :</strong> <code class="language-plaintext highlighter-rouge">a = False b = True c = True</code></li>
</ul>

<!-- end list -->

<ol>
  <li>Si A et B sont des variables booléennes, laquelle de ces expressions
booléennes est équivalente<br />
à <code class="language-plaintext highlighter-rouge">(not A) or B</code> ?</li>
</ol>

<!-- end list -->

<ul>
  <li><strong>Réponse A :</strong> <code class="language-plaintext highlighter-rouge">(A and B) or (not A and B)</code></li>
  <li><strong>Réponse B :</strong> <code class="language-plaintext highlighter-rouge">(A and B) or (not A and B) or (not A and not B)</code></li>
  <li><strong>Réponse C :</strong> <code class="language-plaintext highlighter-rouge">(not A and B) or (not A and not B)</code></li>
  <li><strong>Réponse D :</strong> <code class="language-plaintext highlighter-rouge">(A and B) or (not A and not B)</code></li>
</ul>

<!-- end list -->

<ol>
  <li>Choisir une expression booléenne pour la variable S qui satisfait la
table de vérité suivante.</li>
</ol>

<table>
  <thead>
    <tr>
      <th style="text-align: left">A</th>
      <th style="text-align: left">B</th>
      <th style="text-align: left">S</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">0</td>
      <td style="text-align: left">0</td>
      <td style="text-align: left">1</td>
    </tr>
    <tr>
      <td style="text-align: left">0</td>
      <td style="text-align: left">1</td>
      <td style="text-align: left">0</td>
    </tr>
    <tr>
      <td style="text-align: left">1</td>
      <td style="text-align: left">0</td>
      <td style="text-align: left">1</td>
    </tr>
    <tr>
      <td style="text-align: left">1</td>
      <td style="text-align: left">1</td>
      <td style="text-align: left">1</td>
    </tr>
  </tbody>
</table>

<ul>
  <li><strong>Réponse A :</strong> A ou (non B)</li>
  <li><strong>Réponse B :</strong> (non A) ou B</li>
  <li><strong>Réponse C :</strong> (non A) ou (non B)</li>
  <li><strong>Réponse D :</strong> non (A ou B)</li>
</ul>

<!-- end list -->

<ol>
  <li>On considère une formule booléenne form des variables booléennes <code class="language-plaintext highlighter-rouge">a</code>
et <code class="language-plaintext highlighter-rouge">b</code> dont voici la table de vérité.</li>
</ol>

<table>
  <thead>
    <tr>
      <th style="text-align: left">a</th>
      <th style="text-align: left">b</th>
      <th>form</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">True</td>
      <td style="text-align: left">True</td>
      <td>False</td>
    </tr>
    <tr>
      <td style="text-align: left">False</td>
      <td style="text-align: left">True</td>
      <td>False</td>
    </tr>
    <tr>
      <td style="text-align: left">True</td>
      <td style="text-align: left">False</td>
      <td>True</td>
    </tr>
    <tr>
      <td style="text-align: left">False</td>
      <td style="text-align: left">False</td>
      <td>False</td>
    </tr>
  </tbody>
</table>

<p>Quelle est cette formule booléenne ?</p>

<ul>
  <li><strong>Réponse A :</strong> <code class="language-plaintext highlighter-rouge">a and b</code></li>
  <li><strong>Réponse B :</strong> <code class="language-plaintext highlighter-rouge">a or b</code></li>
  <li><strong>Réponse C :</strong> <code class="language-plaintext highlighter-rouge">a and not(b)</code></li>
  <li><strong>Réponse D :</strong> <code class="language-plaintext highlighter-rouge">not(a) or b</code></li>
</ul>

<p><a href="videos/exercice6.mp4">Tutoriel video : exercice 6</a></p>

<h2 id="pour-aller-plus-loin-hors-programme-de-première-nsi">Pour aller plus loin (hors programme de première NSI)</h2>

<h3 id="dresser-la-table-de-vérité-dune-fonction-booléenne">Dresser la table de vérité d’une fonction booléenne</h3>

<p><strong>Exercice 7</strong></p>

<p>Démontrer dans chaque cas l’égalité des expressions booléennes en
utilisant les deux méthodes suivantes :</p>

<ul>
  <li>
    <p><strong>Méthode 1</strong> : en comparant les tables de vérité des deux
expressions booléennes ;</p>
  </li>
  <li>
    <p><strong>Méthode 2</strong> : en utilisant les règles de simplification de la
propriété 2.</p>
  </li>
</ul>

<!-- end list -->

<ol>
  <li><img src="https://latex.codecogs.com/png.latex?x%20%2B%20x%20.%20y%20%3D%20x" alt="x + x . y =
x" title="x + x . y = x" /></li>
  <li><img src="https://latex.codecogs.com/png.latex?x%20%2B%20%5Coverline%7Bx%7D%20.%20y%3D%20x%20%2B%20y" alt="x + \overline{x} . y= x +
y" title="x + \\overline{x} . y= x + y" /></li>
  <li><img src="https://latex.codecogs.com/png.latex?x%20.%20z%20%2B%20%5Coverline%7Bx%7D%20.%20y%20%2B%20y%20.%20z%20%3D%20x%20.%20z%20%2B%20%5Coverline%7Bx%7D%20.%20y" alt="x . z + \overline{x} . y + y . z = x . z + \overline{x} .
y" title="x . z + \\overline{x} . y + y . z = x . z + \\overline{x} . y" /></li>
  <li><img src="https://latex.codecogs.com/png.latex?%5Coverline%7By%20.%20%28x%20%2B%20%5Coverline%7By%7D%29%7D%20%3D%20%5Coverline%7Bx%7D%20%2B%20%5Coverline%7By%7D" alt="\overline{y . (x + \overline{y})} = \overline{x} +
\overline{y}" title="\\overline{y . (x + \\overline{y})} = \\overline{x} + \\overline{y}" /></li>
  <li><img src="https://latex.codecogs.com/png.latex?x%20.%20%28%20%5Coverline%7Bx%7D%20%2B%20%5Coverline%7By%7D%29%20.%20%28x%20%2B%20y%29%20%3D%20x%20.%20%5Coverline%7By%7D" alt="x . ( \overline{x} + \overline{y}) . (x + y) = x .
\overline{y}" title="x . ( \\overline{x} + \\overline{y}) . (x + y) = x . \\overline{y}" /></li>
</ol>

<h3 id="exprimer-une-fonction-booléenne-à-partir-de-sa-table-de-vérité">Exprimer une fonction booléenne à partir de sa table de vérité</h3>

<p><strong>Exercice 8</strong></p>

<p>On considère la fonction booléenne dont la table de vérité est :</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="https://latex.codecogs.com/png.latex?x" alt="x" title="x" /></th>
      <th><img src="https://latex.codecogs.com/png.latex?y" alt="y" title="y" /></th>
      <th><img src="https://latex.codecogs.com/png.latex?f%28x%2C%20y%29" alt="f(x, y)" title="f(x, y)" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td style="text-align: center">0</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<ol>
  <li>Exprimer chacune des lignes où la fonction prend la valeur
<img src="https://latex.codecogs.com/png.latex?1" alt="1" title="1" /> comme la
<em>conjonction</em> des entrées en remplaçant chaque
<img src="https://latex.codecogs.com/png.latex?1" alt="1" title="1" /> par la variable
qu’il représente et chaque
<img src="https://latex.codecogs.com/png.latex?0" alt="0" title="0" /> par la négation de
la variable. Par exemple le
<img src="https://latex.codecogs.com/png.latex?1" alt="1" title="1" /> de la deuxième
ligne s’écrira <img src="https://latex.codecogs.com/png.latex?%5Coverline%7Bx%7D%20.%20y" alt="\overline{x} .
y" title="\\overline{x} . y" />.</li>
  <li>On peut alors écrire
<img src="https://latex.codecogs.com/png.latex?f%28x%2Cy%29" alt="f(x,y)" title="f(x,y)" /> comme la <em>disjonction</em> des <em>formes conjonctives</em> obtenues
à la question précédente. En déduire une expression booléenne de
<img src="https://latex.codecogs.com/png.latex?f%28x%2C%20y%29" alt="f(x, y)" title="f(x, y)" />.</li>
  <li>Ouvrir le logiciel <a href="http://www.cburch.com/logisim/">Logisim</a> et
construire une porte logique représentant cette fonction booléenne.</li>
  <li>Cette fonction s’appelle <code class="language-plaintext highlighter-rouge">OU EXCLUSIF</code> ou <code class="language-plaintext highlighter-rouge">XOR</code>. Ce nom vous
paraît-il bien choisi ?</li>
</ol>

<p><strong>Voici les représentations symboliques de la porte logique <code class="language-plaintext highlighter-rouge">XOR</code> :</strong></p>

<p><img src="images/porte_xor_european.png" alt="Porte XOR europeenne" /><br />
&amp; <img src="images/porte_xor_american.png" alt="Porte XOR americaine" /></p>

<h1 id="circuits-combinatoires">Circuits combinatoires</h1>

<h2 id="définition">Définition</h2>

<p><strong>Définition 3</strong></p>

<p>Un <strong>circuit logique combinatoire</strong> permet de réaliser une ou plusieurs
fonctions booléennes : ses sorties ne dépendent que de l’état actuel de
ses entrées. Les portes logiques <code class="language-plaintext highlighter-rouge">NOT</code>, <code class="language-plaintext highlighter-rouge">NOR</code>, <code class="language-plaintext highlighter-rouge">NAND</code>, <code class="language-plaintext highlighter-rouge">AND</code>, <code class="language-plaintext highlighter-rouge">OR</code> et
<code class="language-plaintext highlighter-rouge">XOR</code> sont des circuits combinatoires.</p>

<p>Il existe d’autres circuits, dits séquentiels, dont les sorties se
calculent non seulement à partir de leurs valeurs d’entrée actuelles
mais aussi à partir de leurs états précédents : le facteur temps
intervient. Ils utilisent des circuits de mémoire pour mémoriser leurs
états antérieurs.</p>

<p><strong>Exercice 9</strong></p>

<p>On considère la fonction booléeenne
<img src="https://latex.codecogs.com/png.latex?f" alt="f" title="f" /> dont la table de vérité
est donnée ci-dessous :</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="https://latex.codecogs.com/png.latex?x" alt="x" title="x" /></th>
      <th><img src="https://latex.codecogs.com/png.latex?y" alt="y" title="y" /></th>
      <th><img src="https://latex.codecogs.com/png.latex?f%28x%2C%20y%29" alt="f(x, y)" title="f(x, y)" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <td style="text-align: center">0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>1</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<ol>
  <li>
    <p>En utilisant la méthode exposée dans l’exercice 8, déterminer une
expression booléenne de la fonction
<img src="https://latex.codecogs.com/png.latex?f" alt="f" title="f" />.</p>
  </li>
  <li>
    <p>Ouvrir le logiciel <a href="http://www.cburch.com/logisim/">Logisim</a> et
construire un circuit combinatoire représentant cette fonction
booléenne :</p>

    <ul>
      <li>En utilisant les portes logiques <code class="language-plaintext highlighter-rouge">NOT</code>, <code class="language-plaintext highlighter-rouge">NOR</code>, <code class="language-plaintext highlighter-rouge">NAND</code>, <code class="language-plaintext highlighter-rouge">AND</code>,
<code class="language-plaintext highlighter-rouge">OR</code> ou <code class="language-plaintext highlighter-rouge">XOR</code>.</li>
      <li>En n’utilisant que des portes logiques <code class="language-plaintext highlighter-rouge">NOT</code>, <code class="language-plaintext highlighter-rouge">AND</code> ou <code class="language-plaintext highlighter-rouge">OR</code>.</li>
      <li>En n’utilisant que des portes logiques <code class="language-plaintext highlighter-rouge">NOR</code>.</li>
    </ul>
  </li>
</ol>

<p><a href="videos/exercice9.mp4">Tutoriel video : exercice 9</a></p>

<h2 id="décodeur-avec-2-bits-dentrées">Décodeur avec 2 bits d’entrées</h2>

<p><strong>Exercice 10</strong></p>

<p>On considère un circuit combinatoire qui possède deux entrées
<img src="https://latex.codecogs.com/png.latex?e_%7B0%7D" alt="e_{0}" title="e_{0}" /> et
<img src="https://latex.codecogs.com/png.latex?e_%7B1%7D" alt="e_{1}" title="e_{1}" /> et
quatre sorties <img src="https://latex.codecogs.com/png.latex?s_%7B0%7D" alt="s_{0}" title="s_{0}" />, <img src="https://latex.codecogs.com/png.latex?s_%7B1%7D" alt="s_{1}" title="s_{1}" />, <img src="https://latex.codecogs.com/png.latex?s_%7B2%7D" alt="s_{2}" title="s_{2}" /> et <img src="https://latex.codecogs.com/png.latex?s_%7B3%7D" alt="s_{3}" title="s_{3}" />.</p>

<p>La sortie indexée par le nombre dont le bit de poids faible est
<img src="https://latex.codecogs.com/png.latex?e_%7B0%7D" alt="e_{0}" title="e_{0}" /> et le
bit de poids fort
<img src="https://latex.codecogs.com/png.latex?e_%7B1%7D" alt="e_{1}" title="e_{1}" />, est
positionnée à <img src="https://latex.codecogs.com/png.latex?1" alt="1" title="1" /> et les
autres sorties à <img src="https://latex.codecogs.com/png.latex?0" alt="0" title="0" />. Ce
circuit est ainsi appelé <strong>décodeur
<img src="https://latex.codecogs.com/png.latex?2" alt="2" title="2" /> bits</strong>.</p>

<ol>
  <li>Compléter la table de vérité de ce circuit combinatoire.</li>
</ol>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="https://latex.codecogs.com/png.latex?e_%7B0%7D" alt="e_{0}" title="e_{0}" /></th>
      <th><img src="https://latex.codecogs.com/png.latex?e_%7B1%7D" alt="e_{1}" title="e_{1}" /></th>
      <th><img src="https://latex.codecogs.com/png.latex?s_%7B0%7D" alt="s_{0}" title="s_{0}" /></th>
      <th><img src="https://latex.codecogs.com/png.latex?s_%7B1%7D" alt="s_{1}" title="s_{1}" /></th>
      <th><img src="https://latex.codecogs.com/png.latex?s_%7B2%7D" alt="s_{2}" title="s_{2}" /></th>
      <th><img src="https://latex.codecogs.com/png.latex?s_%7B3%7D" alt="s_{3}" title="s_{3}" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td>0</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">0</td>
      <td>1</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>0</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>1</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<ol>
  <li>
    <p>En utilisant la méthode exposée dans l’exercice 7, déterminer une
expression booléenne de chacune des sorties
<img src="https://latex.codecogs.com/png.latex?s_%7B0%7D" alt="s_{0}" title="s_{0}" />,
<img src="https://latex.codecogs.com/png.latex?s_%7B1%7D" alt="s_{1}" title="s_{1}" />,
<img src="https://latex.codecogs.com/png.latex?s_%7B2%7D" alt="s_{2}" title="s_{2}" /> et
<img src="https://latex.codecogs.com/png.latex?s_%7B3%7D" alt="s_{3}" title="s_{3}" />,
en fonction des entrées
<img src="https://latex.codecogs.com/png.latex?e_%7B0%7D" alt="e_{0}" title="e_{0}" /> et
<img src="https://latex.codecogs.com/png.latex?e_%7B1%7D" alt="e_{1}" title="e_{1}" />.</p>
  </li>
  <li>
    <p>Ouvrir le logiciel <a href="http://www.cburch.com/logisim/">Logisim</a> et
construire un circuit combinatoire représentant un <strong>décodeur
<img src="https://latex.codecogs.com/png.latex?2" alt="2" title="2" /> bits</strong>.</p>
  </li>
</ol>

<h2 id="demi-additionneur-et-additionneur-1-bit">Demi-additionneur et additionneur 1 bit</h2>

<p><strong>Exercice 11</strong></p>

<ol>
  <li>
    <p>Effectuer les additions binaires :
<img src="https://latex.codecogs.com/png.latex?0%2B0" alt="0+0" title="0+0" />,
<img src="https://latex.codecogs.com/png.latex?0%2B1" alt="0+1" title="0+1" />,
<img src="https://latex.codecogs.com/png.latex?1%2B0" alt="1+0" title="1+0" /> et
<img src="https://latex.codecogs.com/png.latex?1%2B1" alt="1+1" title="1+1" />.</p>
  </li>
  <li>
    <p>Un <strong>demi-additionneur binaire 1 bit</strong> est un circuit combinatoire
qui possède :</p>

    <ul>
      <li>deux entrées : deux bits d’opérande
<img src="https://latex.codecogs.com/png.latex?e_%7B0%7D" alt="e_{0}" title="e_{0}" /> et
<img src="https://latex.codecogs.com/png.latex?e_%7B1%7D" alt="e_{1}" title="e_{1}" /> ;</li>
      <li>deux sorties : un bit de résultat
<img src="https://latex.codecogs.com/png.latex?s" alt="s" title="s" /> et un bit de
retenue sortante <img src="https://latex.codecogs.com/png.latex?r" alt="r" title="r" />.</li>
    </ul>
  </li>
</ol>

<p>La sortie <img src="https://latex.codecogs.com/png.latex?s" alt="s" title="s" /> prend pour
valeur le bit des unités et la sortie
<img src="https://latex.codecogs.com/png.latex?r" alt="r" title="r" /> le bit de retenue
sortante, lorsqu’on additionne les deux bits d’entrée
<img src="https://latex.codecogs.com/png.latex?e_%7B0%7D" alt="e_{0}" title="e_{0}" /> et
<img src="https://latex.codecogs.com/png.latex?e_%7B1%7D" alt="e_{1}" title="e_{1}" />.</p>

<ol>
  <li>Compléter la table de vérité de ce circuit combinatoire :</li>
</ol>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="https://latex.codecogs.com/png.latex?e_%7B0%7D" alt="e_{0}" title="e_{0}" /></th>
      <th><img src="https://latex.codecogs.com/png.latex?e_%7B1%7D" alt="e_{1}" title="e_{1}" /></th>
      <th><img src="https://latex.codecogs.com/png.latex?s" alt="s" title="s" /></th>
      <th><img src="https://latex.codecogs.com/png.latex?r" alt="r" title="r" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td>0</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">0</td>
      <td>1</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>0</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>1</td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<ol>
  <li>Justifier qu’un <strong>demi-additionneur binaire 1 bit</strong> peut être
représenté par le circuit ci-dessous.</li>
</ol>

<p><img src="images/demi_additionneur.png" alt="Demi-additionneur binaire" /></p>

<ol>
  <li>Ouvrir le logiciel <a href="http://www.cburch.com/logisim/">Logisim</a> et
construire un circuit combinatoire représentant un
<strong>demi-additionneur binaire 1 bit</strong>.</li>
</ol>

<p><a href="videos/exercice11.mp4">Tutoriel video : exercice 11</a></p>

<p><strong>Exercice 12</strong></p>

<p>Un <strong>additionneur binaire 1 bit</strong> est un circuit combinatoire qui
possède :</p>

<ul>
  <li>trois entrées : deux bits d’opérande
<img src="https://latex.codecogs.com/png.latex?e_%7B0%7D" alt="e_{0}" title="e_{0}" /> et
<img src="https://latex.codecogs.com/png.latex?e_%7B1%7D" alt="e_{1}" title="e_{1}" /> et
un bit de retenue entrante
<img src="https://latex.codecogs.com/png.latex?r_%7B0%7D" alt="r_{0}" title="r_{0}" /></li>
  <li>deux bits de sortie : un bit de résultat
<img src="https://latex.codecogs.com/png.latex?s_%7B2%7D" alt="s_{2}" title="s_{2}" /> et
un bit de retenue sortante
<img src="https://latex.codecogs.com/png.latex?r_%7B3%7D" alt="r_{3}" title="r_{3}" />.</li>
</ul>

<!-- end list -->

<ol>
  <li>Compléter les colonnes de la table de vérité d’un <strong>additionneur
binaire 1 bit</strong> pour le bit de résultat
<img src="https://latex.codecogs.com/png.latex?s_%7B2%7D" alt="s_{2}" title="s_{2}" /> et
le bit retenue sortante
<img src="https://latex.codecogs.com/png.latex?r_%7B3%7D" alt="r_{3}" title="r_{3}" />.</li>
</ol>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="https://latex.codecogs.com/png.latex?e_%7B0%7D" alt="e_{0}" title="e_{0}" /></th>
      <th><img src="https://latex.codecogs.com/png.latex?e_%7B1%7D" alt="e_{1}" title="e_{1}" /></th>
      <th><img src="https://latex.codecogs.com/png.latex?r_%7B0%7D" alt="r_{0}" title="r_{0}" /></th>
      <th><img src="https://latex.codecogs.com/png.latex?s_%7B1%7D%3D%5Cldots%20%5Cldots" alt="s_{1}=\ldots \ldots" title="s_{1}=\\ldots \\ldots" /></th>
      <th><img src="https://latex.codecogs.com/png.latex?r_%7B1%7D%3D%5Cldots%20%5Cldots" alt="r_{1}=\ldots \ldots" title="r_{1}=\\ldots \\ldots" /></th>
      <th><img src="https://latex.codecogs.com/png.latex?s_%7B2%7D%3D%5Cldots%20%5Cldots" alt="s_{2}=\ldots \ldots" title="s_{2}=\\ldots \\ldots" /></th>
      <th><img src="https://latex.codecogs.com/png.latex?r_%7B2%7D%3D%5Cldots%20%5Cldots" alt="r_{2}=\ldots \ldots" title="r_{2}=\\ldots \\ldots" /></th>
      <th><img src="https://latex.codecogs.com/png.latex?r_%7B3%7D%3D%5Cldots%20%5Cldots" alt="r_{3}=\ldots \ldots" title="r_{3}=\\ldots \\ldots" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td>0</td>
      <td>0</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">0</td>
      <td>1</td>
      <td>0</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>0</td>
      <td>0</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>1</td>
      <td>0</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">0</td>
      <td>0</td>
      <td>1</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">0</td>
      <td>1</td>
      <td>1</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>0</td>
      <td>1</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>1</td>
      <td>1</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<ol>
  <li>
    <p>Un <strong>additionneur binaire 1 bit</strong> peut être réalisé à l’aide de deux
<strong>demi-additionneurs binaires 1 bit</strong> :</p>

    <ul>
      <li>Le premier <strong>demi-additionneur binaire 1 bit</strong> prend en entrée
les bits d’opérande
<img src="https://latex.codecogs.com/png.latex?e_%7B0%7D" alt="e_{0}" title="e_{0}" /> et
<img src="https://latex.codecogs.com/png.latex?e_%7B1%7D" alt="e_{1}" title="e_{1}" /> et retourne en sortie un bit de résultat intermédiaire
<img src="https://latex.codecogs.com/png.latex?s_%7B1%7D" alt="s_{1}" title="s_{1}" /> et un bit de retenue sortante intermédiaire
<img src="https://latex.codecogs.com/png.latex?r_%7B1%7D" alt="r_{1}" title="r_{1}" />. Donner une expression booléenne de
<img src="https://latex.codecogs.com/png.latex?s_%7B1%7D" alt="s_{1}" title="s_{1}" /> et
<img src="https://latex.codecogs.com/png.latex?r_%7B1%7D" alt="r_{1}" title="r_{1}" /> en fonction de
<img src="https://latex.codecogs.com/png.latex?e_%7B0%7D" alt="e_{0}" title="e_{0}" /> et
<img src="https://latex.codecogs.com/png.latex?e_%7B1%7D" alt="e_{1}" title="e_{1}" />.</li>
      <li>Le second <strong>demi-additionneur binaire 1 bit</strong> prend en entrée le
bit de résultat
<img src="https://latex.codecogs.com/png.latex?s_%7B1%7D" alt="s_{1}" title="s_{1}" /> et le bit de retenue entrante
<img src="https://latex.codecogs.com/png.latex?r_%7B0%7D" alt="r_{0}" title="r_{0}" /> et retourne en sortie le bit de résultat final
<img src="https://latex.codecogs.com/png.latex?s_%7B2%7D" alt="s_{2}" title="s_{2}" /> et un bit de retenue sortante intermédiaire
<img src="https://latex.codecogs.com/png.latex?r_%7B2%7D" alt="r_{2}" title="r_{2}" />. Donner une expression booléenne de
<img src="https://latex.codecogs.com/png.latex?s_%7B2%7D" alt="s_{2}" title="s_{2}" /> et
<img src="https://latex.codecogs.com/png.latex?r_%7B2%7D" alt="r_{2}" title="r_{2}" /> en fonction de
<img src="https://latex.codecogs.com/png.latex?s_%7B1%7D" alt="s_{1}" title="s_{1}" /> et
<img src="https://latex.codecogs.com/png.latex?r_%7B0%7D" alt="r_{0}" title="r_{0}" />.</li>
      <li>Enfin, la retenue sortante
<img src="https://latex.codecogs.com/png.latex?r_%7B3%7D" alt="r_{3}" title="r_{3}" /> s’obtient à partir de la retenue sortante
<img src="https://latex.codecogs.com/png.latex?r_%7B1%7D" alt="r_{1}" title="r_{1}" /> du premier demi-additionneur et de la retenue sortante
<img src="https://latex.codecogs.com/png.latex?r_%7B2%7D" alt="r_{2}" title="r_{2}" /> du second. Donner une expression booléenne de
<img src="https://latex.codecogs.com/png.latex?r_%7B3%7D" alt="r_{3}" title="r_{3}" /> en fonction de
<img src="https://latex.codecogs.com/png.latex?r_%7B1%7D" alt="r_{1}" title="r_{1}" /> et
<img src="https://latex.codecogs.com/png.latex?r_%7B2%7D" alt="r_{2}" title="r_{2}" />.</li>
    </ul>

    <p>Compléter les colonnes
<img src="https://latex.codecogs.com/png.latex?s_%7B1%7D" alt="s_{1}" title="s_{1}" />,
<img src="https://latex.codecogs.com/png.latex?r_%7B1%7D" alt="r_{1}" title="r_{1}" /> et
<img src="https://latex.codecogs.com/png.latex?r_%7B2%7D" alt="r_{2}" title="r_{2}" />
puis <img src="https://latex.codecogs.com/png.latex?s_%7B2%7D" alt="s_{2}" title="s_{2}" /> et <img src="https://latex.codecogs.com/png.latex?r_%7B3%7D" alt="r_{3}" title="r_{3}" /> de la table de vérité de l’<strong>additionneur binaire à 1
bit</strong>.</p>
  </li>
  <li>
    <p>Avec le logiciel <a href="http://www.cburch.com/logisim/">Logisim</a> ouvrir le
fichier contenant le demi-additionneur de l’exercice précédent.</p>

    <ul>
      <li>Ajouter un nouveau circuit avec <code class="language-plaintext highlighter-rouge">Add a circuit</code> , le nommer
<code class="language-plaintext highlighter-rouge">additionneur1bit</code> puis copier/coller dedans le circuit du
<strong>demi-additionneur binaire 1 bit</strong>. Compléter le circuit pour
obtenir un <strong>additionneur binaire 1 bit</strong>.</li>
      <li>Ajouter un nouveau circuit avec <code class="language-plaintext highlighter-rouge">Add a circuit</code> , le nommer
<code class="language-plaintext highlighter-rouge">additionneur2bits</code> puis copier/coller dedans le circuit de l’
<strong>additionneur binaire 1 bit</strong>. Compléter le circuit pour
obtenir un <strong>additionneur binaire 2 bits</strong>.</li>
    </ul>
  </li>
</ol>

<p><a href="videos/exercice12.mp4">Tutoriel video : exercice 12</a></p>

<h1 id="opérations-bit-à-bit-en-python-hors-programme-de-première-nsi">Opérations bit à bit en <code class="language-plaintext highlighter-rouge">Python</code> (hors programme de première NSI)</h1>

<p><strong>Propriété 3</strong></p>

<p>Les fonctions booléennes élémentaires (<code class="language-plaintext highlighter-rouge">OR</code>, <code class="language-plaintext highlighter-rouge">AND</code>, <code class="language-plaintext highlighter-rouge">NOT</code>, <code class="language-plaintext highlighter-rouge">XOR</code>)
existent en <code class="language-plaintext highlighter-rouge">Python</code> sous la forme d’opérateurs booléens mais sont
également implémentés sous la forme d’opérateurs bit à bit sur les
nombres. Un <em>opérateur bit à bit</em> (<em>bitwise</em> en anglais) s’applique sur
les bits de même poids des représentations binaires de ses opérandes.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Opérateur booléen</th>
      <th>Opérateur bit à bit</th>
      <th style="text-align: left">Exemple</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">and</code> , ET</td>
      <td><code class="language-plaintext highlighter-rouge">&amp;</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">&gt;&gt;&gt; bin(0b101001 &amp; 0b101010)</code></td>
    </tr>
    <tr>
      <td style="text-align: left"> </td>
      <td> </td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'0b101000'</code></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">or</code> , OU</td>
      <td><code class="language-plaintext highlighter-rouge">\|</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">&gt;&gt;&gt; bin(0b101001 \| 0b101010)</code></td>
    </tr>
    <tr>
      <td style="text-align: left"> </td>
      <td> </td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'0b101011'</code></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">xor</code> , OU EXCLUSIF</td>
      <td><code class="language-plaintext highlighter-rouge">^</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">&gt;&gt;&gt; bin(0b101001 ^ 0b101010)</code></td>
    </tr>
    <tr>
      <td style="text-align: left"> </td>
      <td> </td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'0b000011'</code></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">not</code> , NEGATION</td>
      <td><code class="language-plaintext highlighter-rouge">~</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">&gt;&gt;&gt; ~5 #~x retourne -x - 1</code></td>
    </tr>
    <tr>
      <td style="text-align: left"> </td>
      <td> </td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">-6</code></td>
    </tr>
  </tbody>
</table>

<p>Exemples d’utilisation d’opérateurs bit à bit :</p>

<ul>
  <li>On peut utiliser le <code class="language-plaintext highlighter-rouge">ET</code> bit à bit pour sélectionner uniquement
certains bits, par exemple les bits de rang pairs :</li>
</ul>

<!-- end list -->

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">bits_pairs</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">bin</span><span class="p">(</span><span class="n">bits_pairs</span><span class="p">)</span>
<span class="s">'0b1010101'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">bin</span><span class="p">(</span><span class="mi">183</span><span class="p">)</span>
<span class="s">'0b10110111'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">bin</span><span class="p">(</span><span class="mi">183</span> <span class="o">&amp;</span> <span class="n">bits_pairs</span><span class="p">)</span>
<span class="s">'0b10100010'</span>
</code></pre></div></div>

<ul>
  <li>Le <code class="language-plaintext highlighter-rouge">OU EXCLUSIF</code> peut servir à masquer / démasquer une partie de la
représentation binaire d’un nombre (on peut l’employer avec tout
objet codé numériquement comme une image ou un caractère).</li>
</ul>

<!-- end list -->

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">diego</span> <span class="o">=</span> <span class="mi">69</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">masque</span> <span class="o">=</span> <span class="mi">42</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">zorro</span> <span class="o">=</span> <span class="n">diego</span> <span class="o">^</span> <span class="n">masque</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">zorro</span>
<span class="mi">111</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">zorro</span> <span class="o">^</span> <span class="n">masque</span>
<span class="mi">69</span>
</code></pre></div></div>

<p><strong>Exercice 13</strong></p>

<p>Dans un réseau <code class="language-plaintext highlighter-rouge">IP</code> l’adresse <code class="language-plaintext highlighter-rouge">IP</code> d’une machine est constituée d’un
préfixe correspondant à l’adresse du réseau (commune à toutes les
machines du réseau) et à un suffixe machine, identifiant la machine sur
le réseau.</p>

<p>Le préfixe réseau s’obtient à partir de l’adresse <code class="language-plaintext highlighter-rouge">IP</code> de la machine en
faisant un <code class="language-plaintext highlighter-rouge">ET</code> bit à bit avec le masque de sous-réseau.</p>

<p>Par exemple si l’adresse est <code class="language-plaintext highlighter-rouge">192.168.11.12</code> de représentation binaire
<code class="language-plaintext highlighter-rouge">11000000.10101000.00001011.00001011</code> et le masque de sous-réseau est
<code class="language-plaintext highlighter-rouge">255.255.252.0</code> de représentation binaire</p>

<p><code class="language-plaintext highlighter-rouge">11111111.11111111.11111100.00000000</code> alors le préfixe réseau est
<code class="language-plaintext highlighter-rouge">11000000.10101000.00001000.00000000</code> soit <code class="language-plaintext highlighter-rouge">192.168.8.0</code>.</p>

<p>On donne ci-dessous deux fonctions outils :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">ip2liste</span><span class="p">(</span><span class="n">ip</span><span class="p">):</span>
    <span class="s">"Transforme une  adresse IP V4 (type str) en liste d'entiers"</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">champ</span><span class="p">)</span> <span class="k">for</span> <span class="n">champ</span> <span class="ow">in</span> <span class="n">ip</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">'.'</span><span class="p">)]</span>

<span class="k">def</span> <span class="nf">liste2ip</span><span class="p">(</span><span class="n">ipliste</span><span class="p">):</span>
    <span class="s">"Transforme une  liste d'entiers en adresse IP V4 (type str)"</span>
    <span class="k">return</span> <span class="s">'.'</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ipliste</span><span class="p">)</span>
</code></pre></div></div>

<ol>
  <li>
    <p>Écrire une fonction de signature <code class="language-plaintext highlighter-rouge">prefixe_reseau(ip, masque)</code> qui
retourne le préfixe réseau sous forme d’adresse IP V4 (type <code class="language-plaintext highlighter-rouge">str</code>) à
partir d’une adresse IP V4 et d’un masque de sous-réseau.</p>
  </li>
  <li>
    <p>Écrire une fonction de signature <code class="language-plaintext highlighter-rouge">suffixe_machine(ip, masque)</code> qui
retourne le suffixe machine sous forme d’adresse IP V4 (type <code class="language-plaintext highlighter-rouge">str</code>)
à partir d’une adresse IP V4 et d’un masque de sous-réseau.</p>
  </li>
</ol>

<p>Voici un exemple de résultat attendu :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">prefixe_reseau</span><span class="p">(</span><span class="s">'145.245.11.254'</span><span class="p">,</span><span class="s">'255.255.252.0'</span><span class="p">)</span>
<span class="s">'145.245.8.0'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">suffixe_machine</span><span class="p">(</span><span class="s">'145.245.11.254'</span><span class="p">,</span><span class="s">'255.255.252.0'</span><span class="p">)</span>
<span class="s">'0.0.3.254'</span>
</code></pre></div></div>

<p><strong>Propriété 4</strong></p>

<p><code class="language-plaintext highlighter-rouge">Python</code> définit également des opérateurs sur les bits d’un nombre, plus
efficaces que les opérations mathématiques équivalentes :</p>

<ul>
  <li>
    <p>Le décalage de <code class="language-plaintext highlighter-rouge">nombre</code> de <code class="language-plaintext highlighter-rouge">n</code> bits vers la gauche multiplie
<code class="language-plaintext highlighter-rouge">nombre</code> par
<img src="https://latex.codecogs.com/png.latex?2%5E%7Bn%7D" alt="2^{n}" title="2^{n}" />
et s’écrit <code class="language-plaintext highlighter-rouge">nombre &lt;&lt; n</code>.</p>
  </li>
  <li>
    <p>Le décalage de <code class="language-plaintext highlighter-rouge">nombre</code> de <code class="language-plaintext highlighter-rouge">n</code> bits vers la droite divise <code class="language-plaintext highlighter-rouge">nombre</code>
par <img src="https://latex.codecogs.com/png.latex?2%5E%7Bn%7D" alt="2^{n}" title="2^{n}" /> et s’écrit <code class="language-plaintext highlighter-rouge">nombre &gt;&gt; n</code>.</p>
  </li>
</ul>

<p><strong>Exercice 14</strong></p>

<p>Dans l’algorithme de recherche dichotomique, après division en deux de
la zone de recherche, l’algorithme s’appelle lui-même sur l’une des deux
moitiés. C’est un algorithme de type <em>Diviser pour régner</em> qui peut se
programmer récursivement comme nous le verrons en terminale dans le
chapitre sur la récursivité.</p>

<p>Si on note <em>n</em> la taille de la liste, une autre implémentation, non
récursive, est la suivante :</p>

<ul>
  <li>
    <p>on commence la recherche au début de la liste et on avance avec un
pas <code class="language-plaintext highlighter-rouge">pas = n // 2</code> ou <code class="language-plaintext highlighter-rouge">pas = n &gt;&gt; 1</code> jusqu’au premier élément
supérieur à l’élément cherché ;</p>
  </li>
  <li>
    <p>on repart de l’élément précédent le point d’arrêt et on avance
désormais avec un pas divisé par 2 soit :</p>

    <p><code class="language-plaintext highlighter-rouge">pas = pas &gt;&gt; 1</code> ;</p>
  </li>
  <li>
    <p>on répète en boucle ces instructions jusqu’à ce que le pas atteigne
<img src="https://latex.codecogs.com/png.latex?1" alt="1" title="1" />.</p>
  </li>
</ul>

<p>A la fin de de la boucle, on détermine si l’élément précédent le dernier
point d’arrêt est l’élément recherché.</p>

<p>Compléter le code de la fonction <code class="language-plaintext highlighter-rouge">recherche_dicho2</code> qui implémente cet
algorithme.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">recherche_dicho2</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">n</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
    <span class="n">pas</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">pas</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">x</span> <span class="o">+</span> <span class="n">pas</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="p">.................:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">..............</span>
        <span class="n">pas</span> <span class="o">=</span> <span class="p">................</span>
    <span class="k">return</span> <span class="p">............</span>
</code></pre></div></div>

   
   </section>
  
   <hr>

   <footer>
    <p>Binder Jupyter Notebook du site : 
      <a href="https://mybinder.org/v2/gh/parc-nsi/premiere-nsi/HEAD"> 
        <img src="https://mybinder.org/badge_logo.svg" alt="Binder"> </a>
        </p>
    <p>
    <a href="https://parc-nsi.github.io/premiere-nsi/index.html">Retour à la page d'accueil</a>
    </p>
  </footer>

<!-- Fin de la balise container bootstrap -->
  </div>


  <script src="/assets/js/juniper.min.js"></script>
  <script>new Juniper({ repo: 'parc-nsi/premiere-nsi', isolateCells: false , theme: 'monokai'})</script>
</body>
</html> 
