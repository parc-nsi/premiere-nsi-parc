I"Ô<h1 id="crÃ©dits--">CrÃ©dits {-}</h1>

<p><em>Ce cours est largement inspirÃ© du chapitre 22 du manuel NSI de la collection Tortue chez Ellipsen auteurs : Ballabonski, Conchon, Filliatre, Nâ€™Guyen.</em></p>

<h1 id="prÃ©ambule--">PrÃ©ambule {-}</h1>

<p>Les circuits dâ€™un ordinateur manipulent uniquement des 0 ou des 1 reprÃ©sentÃ©s en interne par des tensions hautes ou basses. Les premiers ordinateurs construits dans la pÃ©riode 1945-1950 sont basÃ©s sur une technologie de tube Ã  vide ou tube Ã©lectrique. En 1947, aux laboratoires Bell, <a href="https://fr.wikipedia.org/wiki/Transistor">Shockley, Bardeen et Brattain</a> inventent le <strong>transistor</strong> au <em>germanium</em> un petit composant Ã©lectronique qui se comporte comme un interrupteur.  Les transistors, plus petits et dissipant moins de chaleur, vont supplanter les tubes Ã©lectriques : en 1954 le <em>germanium</em> est remplacÃ© par le <em>silicium</em>, en 1955 apparaissent les premiers ordinateurs entiÃ¨rement transistorisÃ©s, en 1960 le transistor Ã  effet de champ permet lâ€™intÃ©gration de dizaines composants dans un centimÃ¨tre carrÃ©. Les transistors sont ensuite directement gravÃ©s dans une plaque de <em>silicium</em> constituant un <strong>cicrcuit intÃ©grÃ©</strong>. En 1965 Gordon Moore futur directeur dâ€™Intel Ã©nonce la <a href="https://fr.wikipedia.org/wiki/Loi_de_Moore">loi empirique</a> portant son nom qui fixe une feuille de route Ã  lâ€™industrie des mircroprocesseurs :  le doublement de la densitÃ© dâ€™intÃ©gration des transistors tous les deux ans. Cette loi sâ€™est vÃ©rifiÃ©e jusquâ€™Ã  prÃ©sent avec une finesse de gravure dâ€™environ 5 nanomÃ¨tres en 2020.  Le <a href="https://en.wikipedia.org/wiki/Moore%27s_law#/media/File:Moore's_Law_Transistor_Count_1971-2018.png">graphique</a> ci-dessous reprÃ©sente lâ€™Ã©volution du  nombre de transistors par circuit intÃ©grÃ©.</p>

<p>:::center
<img src="images/640px-Moores_Law_Transistor_Count_1971-2018.png" alt="Loi de Moore Source : Wikipedia" />{width=90%}<br />
:::</p>

<h1 id="portes-logiques">Portes logiques</h1>

<h2 id="le-transistor-porte-logique-de-base">Le transistor porte logique de base</h2>

<p>:::definition
Un <strong>transistor</strong> possÃ¨de trois broches : la grille, la  sortie (ou drain) et la source soumis Ã  des Ã©tats de tension haute ou basse quâ€™on peut assimiler aux valeurs binaires 1 et 0 dâ€™un <strong>bit</strong>. Si la tension appliquÃ©e sur la grille est haute (bit Ã   1) alors le transitor laisse passer le courant entre la source dâ€™Ã©nergie et la sortie et cette derniÃ¨re passe Ã  lâ€™Ã©tat de tension basse (bit Ã  0), sinon la sortie reste en tension haute (bit  1).</p>

<p>Une <strong>fonction logique</strong> prend un ou plusieurs bits en entrÃ©e et retourne un ou plusieurs bits en sortie.  Une <strong>porte logique</strong> est un circuit Ã©lectronique reprÃ©sentant une <strong>fonction logique</strong>.</p>

<p>Une <strong>table logique</strong>  reprÃ©sente  les sorties produites par une fonction logique pour toutes les entrÃ©es possibles.</p>

<p>Un transistor reprÃ©sente une fonction logique dont le bit dâ€™entrÃ©e est lâ€™Ã©tat de tension de la grille  et le bit de sortie, lâ€™Ã©tat de tension de la sortie. La <strong>table logique</strong>  (table 1) associÃ©e est celle du  <strong>NON logique</strong> ou <strong>Inverseur</strong>.</p>

<p>Fichier de test <a href="http://www.cburch.com/logisim/">Logisim</a> : <a href="circuits_logisim/transistor.circ">transistor.circ</a>.
:::</p>

<p>:::center
<img src="images/transistor.png" alt="Transistor" />{width=50%}<br />
:::</p>

<p>Table: <strong>Table logique  dâ€™une porte NON</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">A</th>
      <th>B = NON(A)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td>1</td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p><strong>Il existe deux conventions de reprÃ©sentation symbolique des portes logiques, une europÃ©enne et une amÃ©ricaine.</strong></p>

<p>:::{.minipage width=â€0.5\linewidthâ€ center=â€trueâ€}
<img src="images/porte_not_european.png" alt="porte NOT europÃ©eenne" /><br />
&amp;
<img src="images/porte_not_american.png" alt="porte NOT amÃ©ricaine" /><br />
:::</p>

<p><a href="videos/transistor-definition1.mp4">Tutoriel video Logisim  : le transistor</a></p>

<h2 id="dautres-portes-logiques">Dâ€™autres portes logiques</h2>

<h3 id="transistors-en-sÃ©rie-ou-en-parallÃ¨le">Transistors en sÃ©rie ou en parallÃ¨le</h3>

<p>:::exercice
On donne ci-dessous les reprÃ©sentations de deux portes logiques :</p>

<ul>
  <li>La <strong>porte NAND</strong> constituÃ©e de deux transistors en sÃ©rie</li>
  <li>La <strong>porte NOR</strong> constituÃ©e de deux transistors en parallÃ¨le</li>
</ul>

<p>Chacune de  ces portes logiques comportent deux   bits dâ€™entrÃ©e : A pour  la grille du transistor 1 et B pour la grille du transistor 2 et un bit de sortie.</p>

<p>ComplÃ©ter leurs tables logiques.</p>

<p>VÃ©rifier avec <a href="http://www.cburch.com/logisim/">Logisim</a> et les fichiers <a href="circuits_logisim/porte_NAND.circ">porte_NAND.circ</a> et <a href="circuits_logisim/porte_NOR.circ">porte_NOR.circ</a>.</p>

<p><a href="videos/porteNAND.mp4">Tutoriel video Logisim  : porte NAND</a></p>

<p><a href="videos/porteNOR.mp4">Tutoriel video Logisim  : porte NOR</a></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">A</th>
      <th>B</th>
      <th>NAND(A, B)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td>0</td>
      <td>Â </td>
    </tr>
    <tr>
      <td style="text-align: center">0</td>
      <td>1</td>
      <td>Â </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>0</td>
      <td>Â </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>1</td>
      <td>Â </td>
    </tr>
  </tbody>
</table>

<p>| A      | B    | NOR(A, B) |
|:â€”â€”:|â€”â€”|â€”â€”â€”â€”|
| 0      | 0    |            |
| 0      | 1    |            |
| 1      | 0    |            |
| 1      | 1    |            |
:::</p>

<p>:::{.minipage width=â€0.5\linewidthâ€ center=â€trueâ€}
<img src="images/porte_nand.png" alt="Porte NAND" />{width=â€80%â€}<br />
&amp;
<img src="images/porte_nor.png" alt="Porte NOR" />{width=â€80%â€}<br />
:::</p>

<p><strong>Voici les  reprÃ©sentations symboliques des  portes logiques NAND et NOR :</strong></p>

<p>:::{.minipage width=â€0.5\linewidthâ€ center=â€trueâ€}
<img src="images/porte_nand_european.png" alt="Porte NAND europÃ©enne" /><br />
&amp;
<img src="images/porte_nand_american.png" alt="Porte NAND amÃ©ricaine" /><br />
:::</p>

<p>:::{.minipage width=â€0.5\linewidthâ€ center=â€trueâ€}
<img src="images/porte_nor_european.png" alt="Porte NOR europÃ©enne" /><br />
&amp;
<img src="images/porte_nor_american.png" alt="Porte NOR amÃ©ricaine" /><br />
:::</p>

<h3 id="portes-logiques-et-fonctions-logiques-Ã©lÃ©mentaires">Portes logiques et fonctions logiques Ã©lÃ©mentaires</h3>

<p>:::exercice
Fichier de test <a href="http://www.cburch.com/logisim/">Logisim</a> : <a href="circuits_logisim/exercice2.circ">exercice2.circ</a>.</p>

<ol>
  <li>ComplÃ©ter la table logique de la porte logique reprÃ©sentÃ©e par le circuit ci-dessous. Quelle porte logique peut-on ainsi reprÃ©senter ?</li>
</ol>

<p><img src="images/porte_not_with_nor.png" alt="Porte NOT" />\</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">A</th>
      <th>B = f(A)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td>Â </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>Â </td>
    </tr>
  </tbody>
</table>

<ol>
  <li>ComplÃ©ter la table logique de la porte logique reprÃ©sentÃ©e par le circuit ci-dessous. Quelle fonction logique correspond Ã  cette porte logique ?</li>
</ol>

<p><img src="images/porte_and_with_nor.png" alt="Porte AND" />{width=60%}\</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">A</th>
      <th>B</th>
      <th>C = g(A, B)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td>0</td>
      <td>Â </td>
    </tr>
    <tr>
      <td style="text-align: center">0</td>
      <td>1</td>
      <td>Â </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>0</td>
      <td>Â </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>1</td>
      <td>Â </td>
    </tr>
  </tbody>
</table>

<p><a href="videos/exercice2.mp4">Tutoriel video Logisim  : exercice 2</a>
:::</p>

<p>:::exercice
Fichier de test <a href="http://www.cburch.com/logisim/">Logisim</a> : <a href="circuits_logisim/exercice3.circ">exercice3.circ</a>.</p>

<ol>
  <li>ComplÃ©ter la table logique de la porte logique reprÃ©sentÃ©e par le circuit ci-dessous. Quelle porte logique peut-on ainsi reprÃ©senter ?</li>
</ol>

<p><img src="images/porte_not_with_nand.png" alt="Porte NOT" />\</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">A</th>
      <th>B = f(A)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td>Â </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>Â </td>
    </tr>
  </tbody>
</table>

<ol>
  <li>ComplÃ©ter la table logique de la porte logique reprÃ©sentÃ©e par le circuit ci-dessous. Quelle fonction logique correspond Ã  cette porte logique ?</li>
</ol>

<p><img src="images/porte_or_with_nand.png" alt="Porte OR" />{width=60%}\</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">A</th>
      <th>B</th>
      <th>C = g(A, B)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td>0</td>
      <td>Â </td>
    </tr>
    <tr>
      <td style="text-align: center">0</td>
      <td>1</td>
      <td>Â </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>0</td>
      <td>Â </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>1</td>
      <td>Â </td>
    </tr>
  </tbody>
</table>

<p><a href="videos/exercice3.mp4">Tutoriel video Logisim  : exercice 3</a>
:::</p>

<p><strong>Voici les  reprÃ©sentations symboliques des  portes logiques <code class="language-plaintext highlighter-rouge">AND</code> et <code class="language-plaintext highlighter-rouge">OR</code> :</strong></p>

<p>:::{.minipage width=â€0.5\linewidthâ€ center=â€trueâ€}
<img src="images/porte_and_european.png" alt="Porte AND europÃ©enne" /><br />
&amp;
<img src="images/porte_and_american.png" alt="Porte AND amÃ©ricaine" /><br />
:::</p>

<p>:::{.minipage width=â€0.5\linewidthâ€ center=â€trueâ€}
<img src="images/porte_or_european.png" alt="Porte OR europÃ©enne" /><br />
&amp;
<img src="images/porte_or_american.png" alt="Porte OR amÃ©ricaine" /><br />
:::</p>

<p>:::exercice</p>

<ol>
  <li>Construire un circuit reprÃ©sentant une porte <code class="language-plaintext highlighter-rouge">OR</code> uniquement avec des portes <code class="language-plaintext highlighter-rouge">NOR</code>.</li>
  <li>Construire un circuit reprÃ©sentant une porte <code class="language-plaintext highlighter-rouge">AND</code> uniquement avec des portes <code class="language-plaintext highlighter-rouge">NAND</code>.</li>
</ol>

<p>Ainsi chacune des portes, <code class="language-plaintext highlighter-rouge">NAND</code> ou <code class="language-plaintext highlighter-rouge">NOR</code> permet de construire les portes <code class="language-plaintext highlighter-rouge">NOT</code>, <code class="language-plaintext highlighter-rouge">OR</code>, <code class="language-plaintext highlighter-rouge">AND</code>. Toute porte logique  pouvant sâ€™exprimer Ã  lâ€™aide de ces trois portes, les portes <code class="language-plaintext highlighter-rouge">NAND</code> et <code class="language-plaintext highlighter-rouge">NOR</code> sont dites <em>universelles</em>.</p>

<p><a href="videos/exercice4.mp4">Tutoriel video Logisim  : exercice 4</a></p>

<p>:::</p>

<h1 id="fonctions-boolÃ©ennes">Fonctions boolÃ©ennes</h1>

<h2 id="fonctions-boolÃ©ennes-1">Fonctions boolÃ©ennes</h2>

<p>:::definition</p>

<ul>
  <li>Un <strong>boolÃ©en</strong> est un type de donnÃ©es pouvant prendre deux valeurs  <code class="language-plaintext highlighter-rouge">True</code> (Vrai)  ou <code class="language-plaintext highlighter-rouge">False</code> (Faux)  quâ€™on  reprÃ©sente  numÃ©riquement par un <strong>bit</strong> de valeur $1$ pour <code class="language-plaintext highlighter-rouge">True</code> ou $0$ pour <code class="language-plaintext highlighter-rouge">False</code>. Electroniquement, les valeurs 1 et 0 se traduisent  respectivement par des tensions haute ou basse.</li>
  <li>Une <strong>fonction boolÃ©enne</strong> $f$ associe un boolÃ©en Ã  un ou plusieurs boolÃ©ens.</li>
  <li>Une <strong>fonction boolÃ©enne</strong> avec $n$ arguments est dÃ©finie sur un ensemble ${0;1}^n$ Ã  $2^n$ valeurs et prend ses valeurs dans ${0;1}$ qui a $2$ Ã©lÃ©ments. On peut recenser les $2^n$ Ã©valuations  dâ€™une fonction boolÃ©enne Ã  $n$ arguments  dans une <strong>table de vÃ©ritÃ©</strong> qui la  dÃ©finit entiÃ¨rement. Il existe $2^{2^n}$ fonctions boolÃ©ennes Ã  $n$ arguments.</li>
  <li>Une <strong>porte logique</strong> est la reprÃ©sentation sous forme de circuit dâ€™une fonction boolÃ©enne et sa <strong>table logique</strong> est la <strong>table de vÃ©ritÃ©</strong>  de cette fonction.</li>
</ul>

<p>:::</p>

<p>:::exercice</p>

<ol>
  <li>ComplÃ©ter la  fonction <code class="language-plaintext highlighter-rouge">Python</code> ci-dessous pour quâ€™elle affiche la table de vÃ©ritÃ© dâ€™une fonction boolÃ©enne Ã  deux entrÃ©es. Expliquer le rÃ´le de la fonction <code class="language-plaintext highlighter-rouge">int</code>.</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">table_verite_2bits</span><span class="p">(</span><span class="n">fonction</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'|{:^10}|{:^10}|{:^15}|'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="s">'a'</span><span class="p">,</span><span class="s">'b'</span><span class="p">,</span><span class="n">fonction</span><span class="p">.</span><span class="n">__name__</span><span class="o">+</span><span class="s">'(a,b)'</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">.............:</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="p">.............:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">'|{:^10}|{:^10}|{:^15}|'</span><span class="p">.</span><span class="nb">format</span><span class="p">(......,</span> <span class="p">......,</span> 
            <span class="nb">int</span><span class="p">(</span><span class="n">fonction</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="n">a</span><span class="p">),</span><span class="nb">bool</span><span class="p">(</span><span class="n">b</span><span class="p">)))))</span>
</code></pre></div></div>

<ol>
  <li>VÃ©rifier que  les tables de vÃ©ritÃ© affichÃ©es pour les fonctions <code class="language-plaintext highlighter-rouge">bool.__or__</code>, <code class="language-plaintext highlighter-rouge">bool.__and__</code>  et <code class="language-plaintext highlighter-rouge">bool.__not__</code> sont correctes.</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">In</span> <span class="p">[</span><span class="mi">4</span><span class="p">]:</span> <span class="n">table_verite_2bits</span><span class="p">(</span><span class="nb">bool</span><span class="p">.</span><span class="n">__or__</span><span class="p">)</span>                                                                                                                                           
<span class="o">|</span>    <span class="n">a</span>     <span class="o">|</span>    <span class="n">b</span>     <span class="o">|</span>  <span class="n">__or__</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>  <span class="o">|</span>
<span class="o">|</span>    <span class="mi">1</span>     <span class="o">|</span>    <span class="mi">1</span>     <span class="o">|</span>       <span class="mi">1</span>       <span class="o">|</span>
<span class="o">|</span>    <span class="mi">1</span>     <span class="o">|</span>    <span class="mi">0</span>     <span class="o">|</span>       <span class="mi">1</span>       <span class="o">|</span>
<span class="o">|</span>    <span class="mi">0</span>     <span class="o">|</span>    <span class="mi">1</span>     <span class="o">|</span>       <span class="mi">1</span>       <span class="o">|</span>
<span class="o">|</span>    <span class="mi">0</span>     <span class="o">|</span>    <span class="mi">0</span>     <span class="o">|</span>       <span class="mi">0</span>       <span class="o">|</span>
</code></pre></div></div>

<p><a href="videos/exercice5.mp4">Tutoriel video : exercice 5</a>
:::</p>

<p>:::propriete</p>

<p>On peut exprimer toute fonction boolÃ©enne Ã  lâ€™aide de trois fonctions boolÃ©ennes Ã©lÃ©mentaires :</p>

<ul>
  <li>La <em>nÃ©gation</em> de $x$  est une fonction Ã  1 bit dâ€™entrÃ©e (unaire) notÃ©e $\neg x$ ou $\overline{x}$.<br />
Si <code class="language-plaintext highlighter-rouge">x</code> est un boolÃ©en, sa <em>nÃ©gation</em> est <code class="language-plaintext highlighter-rouge">not x</code> en <code class="language-plaintext highlighter-rouge">Python</code>.</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center">$x$</th>
      <th>$\neg x$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td>Â </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>Â </td>
    </tr>
  </tbody>
</table>

<ul>
  <li>La <em>conjonction</em> de $x$ et $y$  est une fonction Ã  2 bits dâ€™entrÃ©e (binaire) notÃ©e $x \wedge y$ ou $x . y$.<br />
Si <code class="language-plaintext highlighter-rouge">x</code> et <code class="language-plaintext highlighter-rouge">y</code> sont des boolÃ©ens, leur  <em>conjonction</em> est <code class="language-plaintext highlighter-rouge">x and y</code> en <code class="language-plaintext highlighter-rouge">Python</code>.</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center">$x$</th>
      <th>$y$</th>
      <th>$x \wedge y$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td>0</td>
      <td>Â </td>
    </tr>
    <tr>
      <td style="text-align: center">0</td>
      <td>1</td>
      <td>Â </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>0</td>
      <td>Â </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>1</td>
      <td>Â </td>
    </tr>
  </tbody>
</table>

<ul>
  <li>La <em>disconjonction</em> de $x$ et $y$  est une fonction Ã  2 bits dâ€™entrÃ©e (binaire) notÃ©e $x \vee y$ ou $x + y$.<br />
Si <code class="language-plaintext highlighter-rouge">x</code> et <code class="language-plaintext highlighter-rouge">y</code> sont des boolÃ©ens, leur  <em>disjonction</em> est <code class="language-plaintext highlighter-rouge">x or y</code> en <code class="language-plaintext highlighter-rouge">Python</code>.</li>
</ul>

<p>| $x$ | $y$ | $x \vee y$ |
|:â€”:|â€”â€“|â€”â€”â€”â€”â€“|
| 0   | 0   |              |
| 0   | 1   |              |  <br />
| 1   | 0   |              | <br />
| 1   | 1   |              |
:::</p>

<p>:::propriete</p>
<ol>
  <li>Les fonctions boolÃ©ennes Ã©lÃ©mentaires respectent un certain nombre de rÃ¨gles qui permettent de simplifier les expressions boolÃ©ennes complexes :</li>
</ol>

<ul>
  <li><em>opÃ©rateur involutif</em> :  $\neg(\neg x) = x$ et $\overline{\overline{x}}=x$</li>
  <li><em>Ã©lÃ©ment neutre</em> :   $1 \wedge x = x$ et $1 . x =x$  ou  $0 \vee x = x$ et $0 + x =x$</li>
  <li><em>Ã©lÃ©ment absorbant</em> :   $0 \wedge x = 0$ et $0 . x =0$  ou  $1 \vee x = x$ et $1 + x =1$</li>
  <li><em>idempotence</em> : $x \wedge x = x$ et $x . x =x$  ou  $x \vee x = x$ et $x + x =x$</li>
  <li><em>complÃ©ment</em> : $x \wedge (\neg x) = 0$ et $x . (\overline{x}) =0$  ou  $x \vee (\neg x) = 1$ et $x + \overline{x} =1$</li>
  <li><em>commutativitÃ©</em> :  $x \wedge y = y \wedge x$ et $x . y = y . x$  ou  $x \vee y = y \vee x$ et $x + y = y + x$</li>
  <li><em>associativitÃ©</em> :  $x \wedge ( y \wedge z) = (x \wedge  y) \wedge z$ et $x . (y . z) = (x . y) . z$  ou $x \vee ( y \vee z) = (x \vee y) \vee z$ et $x + (y + z) = (x + y) + z$</li>
  <li><em>distributivitÃ©</em> :  $x \wedge ( y \vee z)  = (x \wedge  y) \vee (x \wedge z)$ et $x . (y + z) = x . y + x . z$  ou  $x \vee ( y \wedge z)  = (x \vee  y) \wedge (x \vee z)$ et $x + (y . z) = (x + y) . (x + z)$</li>
  <li><em>loi de Morgan</em> : $\neg(x \wedge y) = \neg x \vee \neg y$ et   $\overline{x . y} = \overline{x} + \overline{y}$ ou  $\neg(x \vee y) = \neg x \wedge \neg y$ et   $\overline{x + y} = \overline{x} . \overline{y}$</li>
</ul>

<ol>
  <li>Les fonctions boolÃ©ennes Ã©lÃ©mentaire respectent des rÃ¨gles de prioritÃ© :  la <em>nÃ©gation</em> est prioritaire sur la <em>conjonction</em> qui est prioritaire sur la <em>disjonction</em>.<br />
<strong>Il est recommandÃ© de mettre des parenthÃ¨ses plutÃ´t que dâ€™appliquer les rÃ¨gles de prioritÃ© dans lâ€™Ã©criture des expressions boolÃ©ennes.</strong>
:::</li>
</ol>

<h2 id="qcm-types-e3c">QCM types E3C</h2>

<p>:::exercice</p>

<ol>
  <li>Parmi les quatre expressions suivantes, laquelle sâ€™Ã©value en True ?</li>
</ol>

<ul>
  <li>
    <p><strong>RÃ©ponse A :</strong>  <code class="language-plaintext highlighter-rouge">False and (True and False)</code></p>
  </li>
  <li>
    <p><strong>RÃ©ponse B :</strong>   <code class="language-plaintext highlighter-rouge">False or (True and False)</code></p>
  </li>
  <li>
    <p><strong>RÃ©ponse B :</strong>  <code class="language-plaintext highlighter-rouge">True and (True and False)</code></p>
  </li>
  <li>
    <p><strong>RÃ©ponse C :</strong>  <code class="language-plaintext highlighter-rouge">True or (True and False)</code></p>
  </li>
</ul>

<ol>
  <li>Sachant que lâ€™expression <code class="language-plaintext highlighter-rouge">not(a or b)</code> a la valeur <code class="language-plaintext highlighter-rouge">True</code>, quelles peuvent
Ãªtre les valeurs des variables boolÃ©ennes a et bÂ ?</li>
</ol>

<ul>
  <li><strong>RÃ©ponse A :</strong> <code class="language-plaintext highlighter-rouge">True</code> et <code class="language-plaintext highlighter-rouge">True</code></li>
  <li><strong>RÃ©ponse B :</strong> <code class="language-plaintext highlighter-rouge">False</code> et <code class="language-plaintext highlighter-rouge">True</code></li>
  <li><strong>RÃ©ponse C :</strong> <code class="language-plaintext highlighter-rouge">True</code> et <code class="language-plaintext highlighter-rouge">False</code></li>
  <li><strong>RÃ©ponse D :</strong> <code class="language-plaintext highlighter-rouge">False</code> et <code class="language-plaintext highlighter-rouge">False</code></li>
</ul>

<ol>
  <li>Pour quelles valeurs boolÃ©ennes des variables <code class="language-plaintext highlighter-rouge">a, b</code> et <code class="language-plaintext highlighter-rouge">c</code> lâ€™expression <code class="language-plaintext highlighter-rouge">(a or b) and (not c)</code> a-t-elle pour valeur <code class="language-plaintext highlighter-rouge">True</code></li>
</ol>

<ul>
  <li><strong>RÃ©ponse A :</strong> <code class="language-plaintext highlighter-rouge">a  = True b = False c = True</code></li>
  <li><strong>RÃ©ponse B :</strong> <code class="language-plaintext highlighter-rouge">a  = True b = False c = False</code></li>
  <li><strong>RÃ©ponse C :</strong> <code class="language-plaintext highlighter-rouge">a  = False b = False c = True</code></li>
  <li><strong>RÃ©ponse D :</strong> <code class="language-plaintext highlighter-rouge">a  = False b = True  c = True</code></li>
</ul>

<ol>
  <li>Si A et B sont des variables boolÃ©ennes, laquelle de ces expressions boolÃ©ennes est Ã©quivalente<br />
Ã  <code class="language-plaintext highlighter-rouge">(not A) or B</code> ?</li>
</ol>

<ul>
  <li><strong>RÃ©ponse A :</strong> <code class="language-plaintext highlighter-rouge">(A and B) or (not A and B)</code></li>
  <li><strong>RÃ©ponse B :</strong> <code class="language-plaintext highlighter-rouge">(A and B) or (not A and B) or (not A and not B)</code></li>
  <li><strong>RÃ©ponse C :</strong> <code class="language-plaintext highlighter-rouge">(not A and B) or (not A and not B)</code></li>
  <li><strong>RÃ©ponse D :</strong> <code class="language-plaintext highlighter-rouge">(A and B) or (not A and not B)</code></li>
</ul>

<ol>
  <li>Choisir une expression boolÃ©enne pour la variable S qui satisfait la
table de vÃ©ritÃ© suivante.</li>
</ol>

<p>A   B   S
  â€” â€” â€”
  0   0   1
  0   1   0
  1   0   1
  1   1   1</p>

<ul>
  <li><strong>RÃ©ponse A :</strong>  A ou (non B)</li>
  <li><strong>RÃ©ponse B :</strong> (non A) ou B</li>
  <li><strong>RÃ©ponse C :</strong> (non A) ou (non B)</li>
  <li><strong>RÃ©ponse D :</strong> non (A ou B)</li>
</ul>

<ol>
  <li>On considÃ¨re une formule boolÃ©enne form des variables boolÃ©ennes <code class="language-plaintext highlighter-rouge">a</code> et <code class="language-plaintext highlighter-rouge">b</code> dont voici la table de vÃ©ritÃ©.</li>
</ol>

<p>a     b      form
â€”   â€”-   â€”-
True  True   False 
False True   False 
True  False  True 
False False  False</p>

<p>Quelle est cette formule boolÃ©enne  ?</p>

<ul>
  <li><strong>RÃ©ponse A :</strong>  <code class="language-plaintext highlighter-rouge">a and b</code></li>
  <li><strong>RÃ©ponse B :</strong> <code class="language-plaintext highlighter-rouge">a or b</code></li>
  <li><strong>RÃ©ponse C :</strong> <code class="language-plaintext highlighter-rouge">a and not(b)</code></li>
  <li><strong>RÃ©ponse D :</strong> <code class="language-plaintext highlighter-rouge">not(a) or b</code></li>
</ul>

<p><a href="videos/exercice6.mp4">Tutoriel video  : exercice 6</a></p>

<p>:::</p>

<h2 id="pour-aller-plus-loin-hors-programme-de-premiÃ¨re-nsi">Pour aller plus loin (hors programme de premiÃ¨re NSI)</h2>

<h3 id="dresser-la-table-de-vÃ©ritÃ©-dune-fonction-boolÃ©enne">Dresser la table de vÃ©ritÃ© dâ€™une fonction boolÃ©enne</h3>

<p>:::exercice
DÃ©montrer dans chaque cas lâ€™Ã©galitÃ© des expressions boolÃ©ennes en utilisant les deux mÃ©thodes suivantes :</p>

<ul>
  <li>
    <p><strong>MÃ©thode 1</strong> : en comparant les tables de vÃ©ritÃ© des deux expressions boolÃ©ennes ;</p>
  </li>
  <li>
    <p><strong>MÃ©thode 2</strong> : en utilisant les rÃ¨gles de simplification de la propriÃ©tÃ© 2.</p>
  </li>
</ul>

<ol>
  <li>$x + x . y = x$</li>
  <li>$x + \overline{x} . y= x + y$</li>
  <li>$x . z + \overline{x} . y + y . z = x . z + \overline{x} . y$</li>
  <li>$\overline{y . (x + \overline{y})} = \overline{x} + \overline{y}$</li>
  <li>$x . ( \overline{x} + \overline{y}) . (x + y) = x . \overline{y}$</li>
</ol>

<p>:::</p>

<h3 id="exprimer-une-fonction-boolÃ©enne-Ã -partir-de-sa-table-de-vÃ©ritÃ©">Exprimer une fonction boolÃ©enne Ã  partir de sa table de vÃ©ritÃ©</h3>

<p>:::exercice
On considÃ¨re la fonction boolÃ©enne dont la table de vÃ©ritÃ© est :</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">$x$</th>
      <th>$y$</th>
      <th>$f(x, y)$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td style="text-align: center">0</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<ol>
  <li>Exprimer chacune des lignes oÃ¹ la fonction prend la valeur $1$ comme la <em>conjonction</em> des entrÃ©es en remplaÃ§ant chaque $1$ par la variable quâ€™il reprÃ©sente et chaque $0$ par la nÃ©gation de la variable. Par exemple le $1$ de la deuxiÃ¨me ligne sâ€™Ã©crira $\overline{x} . y$.</li>
  <li>On peut alors Ã©crire $f(x,y)$ comme la <em>disjonction</em> des <em>formes conjonctives</em> obtenues Ã  la question prÃ©cÃ©dente. En dÃ©duire une expression boolÃ©enne de $f(x, y)$.</li>
  <li>Ouvrir le logiciel <a href="http://www.cburch.com/logisim/">Logisim</a> et construire une porte logique reprÃ©sentant cette fonction boolÃ©enne.</li>
  <li>Cette fonction sâ€™appelle <code class="language-plaintext highlighter-rouge">OU EXCLUSIF</code> ou <code class="language-plaintext highlighter-rouge">XOR</code>. Ce nom vous paraÃ®t-il bien choisi ?</li>
</ol>

<p>:::</p>

<p><strong>Voici les  reprÃ©sentations symboliques de la  porte logique <code class="language-plaintext highlighter-rouge">XOR</code> :</strong></p>

<p>:::{.minipage width=â€0.5\linewidthâ€ center=â€trueâ€}
<img src="images/porte_xor_european.png" alt="Porte XOR europeenne" /><br />
&amp;
<img src="images/porte_xor_american.png" alt="Porte XOR americaine" /><br />
:::</p>

<h1 id="circuits-combinatoires">Circuits combinatoires</h1>

<h2 id="dÃ©finition">DÃ©finition</h2>

<p>:::definition
Un <strong>circuit logique combinatoire</strong> permet de rÃ©aliser une ou plusieurs fonctions boolÃ©ennes : ses sorties ne dÃ©pendent que de lâ€™Ã©tat actuel de ses entrÃ©es. Les portes logiques <code class="language-plaintext highlighter-rouge">NOT</code>, <code class="language-plaintext highlighter-rouge">NOR</code>, <code class="language-plaintext highlighter-rouge">NAND</code>, <code class="language-plaintext highlighter-rouge">AND</code>, <code class="language-plaintext highlighter-rouge">OR</code> et <code class="language-plaintext highlighter-rouge">XOR</code> sont des circuits combinatoires.</p>

<p>Il existe dâ€™autres circuits, dits sÃ©quentiels, dont les sorties se calculent non seulement Ã  partir de leurs  valeurs dâ€™entrÃ©e actuelles mais aussi Ã  partir de leurs Ã©tats prÃ©cÃ©dents : le facteur temps intervient. Ils utilisent des circuits de mÃ©moire pour mÃ©moriser leurs Ã©tats antÃ©rieurs.
:::</p>

<p>:::exercice</p>

<p>On considÃ¨re la fonction boolÃ©eenne $f$ dont la table de vÃ©ritÃ© est donnÃ©e ci-dessous :</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">$x$</th>
      <th>$y$</th>
      <th>$f(x, y)$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <td style="text-align: center">0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>1</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<ol>
  <li>En utilisant la mÃ©thode exposÃ©e dans lâ€™exercice 8, dÃ©terminer une expression boolÃ©enne de la fonction $f$.</li>
  <li>
    <p>Ouvrir le logiciel <a href="http://www.cburch.com/logisim/">Logisim</a> et construire un circuit combinatoire  reprÃ©sentant cette fonction boolÃ©enne :</p>

    <ul>
      <li>En utilisant les portes logiques <code class="language-plaintext highlighter-rouge">NOT</code>, <code class="language-plaintext highlighter-rouge">NOR</code>, <code class="language-plaintext highlighter-rouge">NAND</code>, <code class="language-plaintext highlighter-rouge">AND</code>, <code class="language-plaintext highlighter-rouge">OR</code> ou <code class="language-plaintext highlighter-rouge">XOR</code>.</li>
      <li>En nâ€™utilisant que des portes logiques <code class="language-plaintext highlighter-rouge">NOT</code>, <code class="language-plaintext highlighter-rouge">AND</code> ou  <code class="language-plaintext highlighter-rouge">OR</code>.</li>
      <li>En nâ€™utilisant que des portes logiques  <code class="language-plaintext highlighter-rouge">NOR</code>.</li>
    </ul>
  </li>
</ol>

<p><a href="videos/exercice9.mp4">Tutoriel video  : exercice 9</a></p>

<p>:::</p>

<h2 id="dÃ©codeur-avec-2-bits-dentrÃ©es">DÃ©codeur avec 2 bits dâ€™entrÃ©es</h2>

<p>:::exercice</p>

<p>On considÃ¨re un circuit combinatoire qui  possÃ¨de deux entrÃ©es $e_{0}$ et $e_{1}$ et quatre sorties $s_{0}$, $s_{1}$, $s_{2}$ et $s_{3}$.</p>

<p>La sortie indexÃ©e par le nombre dont le bit de poids faible est $e_{0}$ et le bit de poids fort $e_{1}$, est positionnÃ©e Ã  $1$ et les autres sorties Ã  $0$. Ce circuit est ainsi appelÃ© <strong>dÃ©codeur $2$ bits</strong>.</p>

<ol>
  <li>ComplÃ©ter la table de vÃ©ritÃ© de ce circuit combinatoire.</li>
</ol>

<table>
  <thead>
    <tr>
      <th style="text-align: center">$e_{0}$</th>
      <th>$e_{1}$</th>
      <th>$s_{0}$</th>
      <th>$s_{1}$</th>
      <th>$s_{2}$</th>
      <th>$s_{3}$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td>0</td>
      <td>Â </td>
      <td>Â </td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td style="text-align: center">0</td>
      <td>1</td>
      <td>Â </td>
      <td>Â </td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>0</td>
      <td>Â </td>
      <td>Â </td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>1</td>
      <td>Â </td>
      <td>Â </td>
      <td>Â </td>
      <td>Â </td>
    </tr>
  </tbody>
</table>

<ol>
  <li>
    <p>En utilisant la mÃ©thode exposÃ©e dans lâ€™exercice 7, dÃ©terminer une expression boolÃ©enne de chacune des sorties $s_{0}$, $s_{1}$, $s_{2}$ et $s_{3}$, en fonction des entrÃ©es $e_{0}$ et $e_{1}$.</p>
  </li>
  <li>
    <p>Ouvrir le logiciel <a href="http://www.cburch.com/logisim/">Logisim</a> et construire un circuit combinatoire  reprÃ©sentant un <strong>dÃ©codeur $2$ bits</strong>.
:::</p>
  </li>
</ol>

<h2 id="demi-additionneur-et-additionneur--1-bit">Demi-additionneur et additionneur  1 bit</h2>

<p>:::exercice</p>

<ol>
  <li>
    <p>Effectuer les additions binaires : $0+0$, $0+1$, $1+0$ et $1+1$.</p>
  </li>
  <li>
    <p>Un <strong>demi-additionneur binaire 1 bit</strong>  est  un circuit combinatoire qui  possÃ¨de :</p>

    <ul>
      <li>deux entrÃ©es : deux bits dâ€™opÃ©rande $e_{0}$ et $e_{1}$ ;</li>
      <li>deux sorties : un bit de rÃ©sultat  $s$ et un bit de retenue  sortante $r$.</li>
    </ul>
  </li>
</ol>

<p>La sortie $s$ prend pour valeur le bit des unitÃ©s et la sortie $r$ le bit de retenue sortante, lorsquâ€™on additionne les deux bits dâ€™entrÃ©e $e_{0}$ et $e_{1}$.</p>

<ol>
  <li>ComplÃ©ter la table de vÃ©ritÃ© de ce circuit combinatoire :</li>
</ol>

<table>
  <thead>
    <tr>
      <th style="text-align: center">$e_{0}$</th>
      <th>$e_{1}$</th>
      <th>$s$</th>
      <th>$r$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td>0</td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td style="text-align: center">0</td>
      <td>1</td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>0</td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>1</td>
      <td>Â </td>
      <td>Â </td>
    </tr>
  </tbody>
</table>

<ol>
  <li>Justifier quâ€™un <strong>demi-additionneur binaire 1 bit</strong>  peut Ãªtre reprÃ©sentÃ© par le circuit ci-dessous.</li>
</ol>

<p><img src="images/demi_additionneur.png" alt="Demi-additionneur binaire" />{width=â€50%â€}\</p>

<ol>
  <li>Ouvrir le logiciel <a href="http://www.cburch.com/logisim/">Logisim</a> et construire un circuit combinatoire  reprÃ©sentant un <strong>demi-additionneur binaire 1 bit</strong>.</li>
</ol>

<p><a href="videos/exercice11.mp4">Tutoriel video  : exercice 11</a>
:::</p>

<p>:::exercice</p>

<p>Un <strong>additionneur binaire   1 bit</strong> est  un circuit combinatoire qui  possÃ¨de :</p>

<ul>
  <li>trois entrÃ©es : deux bits dâ€™opÃ©rande $e_{0}$ et $e_{1}$ et un bit de retenue entrante $r_{0}$</li>
  <li>deux bits de sortie : un bit de rÃ©sultat  $s_{2}$ et un bit de retenue  sortante $r_{3}$.</li>
</ul>

<ol>
  <li>ComplÃ©ter les colonnes de la table de vÃ©ritÃ© dâ€™un <strong>additionneur binaire   1 bit</strong>  pour le bit de rÃ©sultat $s_{2}$ et le bit  retenue  sortante $r_{3}$.</li>
</ol>

<p>| $e_{0}$ | $e_{1}$ | $r_{0}$ | $s_{1}=\ldots \ldots$ | $r_{1}=\ldots \ldots$ | $s_{2}=\ldots \ldots$ | $r_{2}=\ldots \ldots$ |  $r_{3}=\ldots \ldots$ |
|:â€”â€”-:|â€”â€”â€”|â€”â€”â€”|â€”â€”â€”â€”â€”â€”â€”â€”â€”|â€”â€”â€”â€”â€”â€”â€”â€“|â€”â€”â€”â€”â€”â€”â€”â€”â€”|â€”â€”â€”â€”â€”â€”â€”â€“|â€”â€”â€”â€”â€”â€”â€”â€”|
| 0       | 0       | 0       |                           |                       |                           |                       |                        |
| 0       | 1       | 0       |                           |                       |                           |                       |                        |
| 1       | 0       | 0       |                           |                       |                           |                       |                        |
| 1       | 1       | 0       |                           |                       |                           |                       |                        |
| 0       | 0       | 1       |                           |                       |                           |                       |                        |
| 0       | 1       | 1       |                           |                       |                           |                       |                        |
| 1       | 0       | 1       |                           |                       |                           |                       |                        |
| 1       | 1       | 1       |                           |                       |                           |                       |                        |</p>
<ol>
  <li>
    <p>Un <strong>additionneur binaire   1 bit</strong> peut Ãªtre rÃ©alisÃ© Ã  lâ€™aide de deux <strong>demi-additionneurs binaires 1 bit</strong> :</p>

    <ul>
      <li>Le premier <strong>demi-additionneur binaire 1 bit</strong> prend en entrÃ©e les bits dâ€™opÃ©rande $e_{0}$ et $e_{1}$ et retourne en sortie un bit de rÃ©sultat intermÃ©diaire $s_{1}$ et un bit de retenue sortante intermÃ©diaire $r_{1}$. Donner une expression boolÃ©enne de $s_{1}$ et $r_{1}$ en fonction de $e_{0}$ et $e_{1}$.</li>
      <li>Le second <strong>demi-additionneur binaire 1 bit</strong> prend en entrÃ©e le bit de rÃ©sultat $s_{1}$ et le bit de retenue entrante $r_{0}$ et retourne en sortie le bit de rÃ©sultat  final $s_{2}$ et un bit de retenue sortante intermÃ©diaire $r_{2}$. Donner une expression boolÃ©enne de $s_{2}$ et $r_{2}$ en fonction de $s_{1}$ et $r_{0}$.</li>
      <li>Enfin, la retenue sortante $r_{3}$ sâ€™obtient Ã  partir  de la retenue sortante $r_{1}$ du premier demi-additionneur et de la retenue sortante $r_{2}$ du second. Donner une expression boolÃ©enne de $r_{3}$ en fonction de $r_{1}$ et $r_{2}$.</li>
    </ul>

    <p>ComplÃ©ter les colonnes $s_{1}$, $r_{1}$ et $r_{2}$ puis $s_{2}$ et $r_{3}$ de la table de vÃ©ritÃ© de lâ€™<strong>additionneur binaire Ã   1 bit</strong>.</p>
  </li>
  <li>
    <p>Avec le logiciel <a href="http://www.cburch.com/logisim/">Logisim</a> ouvrir le fichier contenant le demi-additionneur de lâ€™exercice prÃ©cÃ©dent.</p>
    <ul>
      <li>Ajouter un nouveau circuit avec <code class="language-plaintext highlighter-rouge">Add a circuit</code> , le nommer <code class="language-plaintext highlighter-rouge">additionneur1bit</code> puis copier/coller dedans le circuit du <strong>demi-additionneur binaire 1 bit</strong>. ComplÃ©ter le  circuit  pour obtenir  un <strong>additionneur binaire 1 bit</strong>.</li>
      <li>Ajouter un nouveau circuit avec <code class="language-plaintext highlighter-rouge">Add a circuit</code> , le nommer <code class="language-plaintext highlighter-rouge">additionneur2bits</code> puis copier/coller dedans le circuit de lâ€™ <strong>additionneur binaire 1 bit</strong>. ComplÃ©ter le  circuit   pour obtenir  un <strong>additionneur binaire 2 bits</strong>.</li>
    </ul>
  </li>
</ol>

<p><a href="videos/exercice12.mp4">Tutoriel video  : exercice 12</a></p>

<p>:::</p>

<h1 id="opÃ©rations-bit-Ã -bit-en-python-hors-programme-de-premiÃ¨re-nsi">OpÃ©rations bit Ã  bit en <code class="language-plaintext highlighter-rouge">Python</code> (hors programme de premiÃ¨re NSI)</h1>

<p>:::propriete</p>

<p>Les fonctions boolÃ©ennes Ã©lÃ©mentaires (<code class="language-plaintext highlighter-rouge">OR</code>, <code class="language-plaintext highlighter-rouge">AND</code>, <code class="language-plaintext highlighter-rouge">NOT</code>, <code class="language-plaintext highlighter-rouge">XOR</code>) existent en <code class="language-plaintext highlighter-rouge">Python</code> sous la forme dâ€™opÃ©rateurs boolÃ©ens mais sont Ã©galement implÃ©mentÃ©s sous la forme dâ€™opÃ©rateurs bit Ã  bit sur les nombres. Un <em>opÃ©rateur bit  Ã  bit</em> (<em>bitwise</em> en anglais) sâ€™applique sur les bits de mÃªme poids des  reprÃ©sentations binaires de ses opÃ©randes.</p>

<hr />
<p>OpÃ©rateur boolÃ©en      OpÃ©rateur bit Ã  bit  Exemple                               <br />
â€”â€”â€”â€”â€”â€”â€”- â€”â€”â€”â€”â€”â€”-  â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€“
<code class="language-plaintext highlighter-rouge">and</code> , ET             <code class="language-plaintext highlighter-rouge">&amp;</code>                  <code class="language-plaintext highlighter-rouge">&gt;&gt;&gt; bin(0b101001 &amp; 0b101010)</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                                        `'0b101000'` 
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">or</code> , OU              <code class="language-plaintext highlighter-rouge">|</code>                  <code class="language-plaintext highlighter-rouge">&gt;&gt;&gt; bin(0b101001 | 0b101010)</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                                        `'0b101011'` 
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">xor</code> , OU EXCLUSIF    <code class="language-plaintext highlighter-rouge">^</code>                  <code class="language-plaintext highlighter-rouge">&gt;&gt;&gt; bin(0b101001 ^ 0b101010)</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                                        `'0b000011'` 
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">not</code> ,  NEGATION      <code class="language-plaintext highlighter-rouge">~</code>                  <code class="language-plaintext highlighter-rouge">&gt;&gt;&gt; ~5 #~x retourne -x - 1</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                                        `-6`
</code></pre></div></div>

<hr />
<p>:::</p>

<p>Exemples dâ€™utilisation dâ€™opÃ©rateurs bit Ã  bit :</p>

<ul>
  <li>On  peut utiliser le <code class="language-plaintext highlighter-rouge">ET</code> bit Ã  bit pour sÃ©lectionner uniquement certains bits, par exemple les bits de rang pairs :</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">bits_pairs</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">bin</span><span class="p">(</span><span class="n">bits_pairs</span><span class="p">)</span>
<span class="s">'0b1010101'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">bin</span><span class="p">(</span><span class="mi">183</span><span class="p">)</span>
<span class="s">'0b10110111'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">bin</span><span class="p">(</span><span class="mi">183</span> <span class="o">&amp;</span> <span class="n">bits_pairs</span><span class="p">)</span>
<span class="s">'0b10100010'</span>
</code></pre></div></div>

<ul>
  <li>Le <code class="language-plaintext highlighter-rouge">OU EXCLUSIF</code> peut servir Ã  masquer / dÃ©masquer une partie de la reprÃ©sentation binaire dâ€™un nombre (on peut lâ€™employer avec tout objet codÃ© numÃ©riquement comme une image ou un caractÃ¨re).</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">diego</span> <span class="o">=</span> <span class="mi">69</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">masque</span> <span class="o">=</span> <span class="mi">42</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">zorro</span> <span class="o">=</span> <span class="n">diego</span> <span class="o">^</span> <span class="n">masque</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">zorro</span>
<span class="mi">111</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">zorro</span> <span class="o">^</span> <span class="n">masque</span>
<span class="mi">69</span>
</code></pre></div></div>
<p>:::exercice</p>

<p>Dans un rÃ©seau <code class="language-plaintext highlighter-rouge">IP</code> lâ€™adresse <code class="language-plaintext highlighter-rouge">IP</code> dâ€™une machine est constituÃ©e dâ€™un prÃ©fixe correspondant Ã  lâ€™adresse du rÃ©seau (commune Ã  toutes les machines du rÃ©seau) et Ã  un suffixe machine, identifiant la machine sur le rÃ©seau.</p>

<p>Le prÃ©fixe rÃ©seau sâ€™obtient Ã  partir de lâ€™adresse <code class="language-plaintext highlighter-rouge">IP</code> de la  machine en faisant un <code class="language-plaintext highlighter-rouge">ET</code> bit Ã  bit avec le masque de sous-rÃ©seau.</p>

<p>Par exemple si lâ€™adresse est  <code class="language-plaintext highlighter-rouge">192.168.11.12</code>  de reprÃ©sentation binaire <code class="language-plaintext highlighter-rouge">11000000.10101000.00001011.00001011</code> et le masque de sous-rÃ©seau est <code class="language-plaintext highlighter-rouge">255.255.252.0</code> de reprÃ©sentation binaire</p>

<p><code class="language-plaintext highlighter-rouge">11111111.11111111.11111100.00000000</code> alors le prÃ©fixe rÃ©seau est <code class="language-plaintext highlighter-rouge">11000000.10101000.00001000.00000000</code>  soit <code class="language-plaintext highlighter-rouge">192.168.8.0</code>.</p>

<p>On donne ci-dessous deux fonctions outils :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">ip2liste</span><span class="p">(</span><span class="n">ip</span><span class="p">):</span>
    <span class="s">"Transforme une  adresse IP V4 (type str) en liste d'entiers"</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">champ</span><span class="p">)</span> <span class="k">for</span> <span class="n">champ</span> <span class="ow">in</span> <span class="n">ip</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">'.'</span><span class="p">)]</span>

<span class="k">def</span> <span class="nf">liste2ip</span><span class="p">(</span><span class="n">ipliste</span><span class="p">):</span>
    <span class="s">"Transforme une  liste d'entiers en adresse IP V4 (type str)"</span>
    <span class="k">return</span> <span class="s">'.'</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ipliste</span><span class="p">)</span>
</code></pre></div></div>

<ol>
  <li>
    <p>Ã‰crire une fonction de signature <code class="language-plaintext highlighter-rouge">prefixe_reseau(ip, masque)</code> qui retourne le prÃ©fixe rÃ©seau sous forme dâ€™adresse IP V4 (type <code class="language-plaintext highlighter-rouge">str</code>) Ã  partir dâ€™une adresse IP V4 et dâ€™un masque de sous-rÃ©seau.</p>
  </li>
  <li>
    <p>Ã‰crire une fonction de signature <code class="language-plaintext highlighter-rouge">suffixe_machine(ip, masque)</code> qui retourne le suffixe machine sous forme dâ€™adresse IP V4 (type <code class="language-plaintext highlighter-rouge">str</code>) Ã  partir dâ€™une adresse IP V4 et dâ€™un masque de sous-rÃ©seau.</p>
  </li>
</ol>

<p>Voici un exemple de rÃ©sultat attendu :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">prefixe_reseau</span><span class="p">(</span><span class="s">'145.245.11.254'</span><span class="p">,</span><span class="s">'255.255.252.0'</span><span class="p">)</span>
<span class="s">'145.245.8.0'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">suffixe_machine</span><span class="p">(</span><span class="s">'145.245.11.254'</span><span class="p">,</span><span class="s">'255.255.252.0'</span><span class="p">)</span>
<span class="s">'0.0.3.254'</span>
</code></pre></div></div>

<p>:::</p>

<p>:::propriete</p>

<p><code class="language-plaintext highlighter-rouge">Python</code> dÃ©finit Ã©galement des opÃ©rateurs sur les bits dâ€™un nombre, plus efficaces que les opÃ©rations mathÃ©matiques Ã©quivalentes :</p>

<ul>
  <li>
    <p>Le dÃ©calage de <code class="language-plaintext highlighter-rouge">nombre</code> de  <code class="language-plaintext highlighter-rouge">n</code> bits vers la gauche multiplie <code class="language-plaintext highlighter-rouge">nombre</code> par $2^{n}$ et sâ€™Ã©crit  <code class="language-plaintext highlighter-rouge">nombre &lt;&lt; n</code>.</p>
  </li>
  <li>
    <p>Le dÃ©calage de <code class="language-plaintext highlighter-rouge">nombre</code> de  <code class="language-plaintext highlighter-rouge">n</code> bits vers la droite divise <code class="language-plaintext highlighter-rouge">nombre</code> par $2^{n}$ et sâ€™Ã©crit  <code class="language-plaintext highlighter-rouge">nombre &gt;&gt; n</code>.</p>
  </li>
</ul>

<p>:::</p>

<p>:::exercice
Dans lâ€™algorithme de recherche dichotomique, aprÃ¨s  division en deux de  la zone de recherche, lâ€™algorithme  sâ€™appelle lui-mÃªme sur lâ€™une des deux moitiÃ©s. Câ€™est un algorithme de type <em>Diviser pour rÃ©gner</em> qui peut se programmer rÃ©cursivement comme nous le verrons en terminale dans le chapitre sur la rÃ©cursivitÃ©.</p>

<p>Si on note   <em>n</em> la taille de la liste, une autre implÃ©mentation, non rÃ©cursive, est la suivante :</p>

<ul>
  <li>on commence la recherche au dÃ©but de la liste et on avance avec un pas <code class="language-plaintext highlighter-rouge">pas = n // 2</code>   ou <code class="language-plaintext highlighter-rouge">pas = n &gt;&gt; 1</code> jusquâ€™au premier Ã©lÃ©ment supÃ©rieur Ã  lâ€™Ã©lÃ©ment cherchÃ© ;</li>
  <li>
    <p>on repart de lâ€™Ã©lÃ©ment prÃ©cÃ©dent le point dâ€™arrÃªt  et on avance dÃ©sormais avec un pas divisÃ© par 2 soit :</p>

    <p><code class="language-plaintext highlighter-rouge">pas = pas &gt;&gt; 1</code> ;</p>
  </li>
  <li>on rÃ©pÃ¨te en boucle ces instructions jusquâ€™Ã  ce que le pas atteigne $1$.</li>
</ul>

<p>A la fin de de la boucle, on dÃ©termine si lâ€™Ã©lÃ©ment prÃ©cÃ©dent le dernier point dâ€™arrÃªt est lâ€™Ã©lÃ©ment recherchÃ©.</p>

<p>ComplÃ©ter le code de la fonction <code class="language-plaintext highlighter-rouge">recherche_dicho2</code> qui implÃ©mente cet algorithme.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">recherche_dicho2</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">n</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
    <span class="n">pas</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">pas</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">x</span> <span class="o">+</span> <span class="n">pas</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="p">.................:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">..............</span>
        <span class="n">pas</span> <span class="o">=</span> <span class="p">................</span>
    <span class="k">return</span> <span class="p">............</span>
</code></pre></div></div>

<p>:::</p>
:ET