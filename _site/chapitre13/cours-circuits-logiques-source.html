<h1 id="crédits--">Crédits {-}</h1>

<p><em>Ce cours est largement inspiré du chapitre 22 du manuel NSI de la collection Tortue chez Ellipsen auteurs : Ballabonski, Conchon, Filliatre, N’Guyen.</em></p>

<h1 id="préambule--">Préambule {-}</h1>

<p>Les circuits d’un ordinateur manipulent uniquement des 0 ou des 1 représentés en interne par des tensions hautes ou basses. Les premiers ordinateurs construits dans la période 1945-1950 sont basés sur une technologie de tube à vide ou tube électrique. En 1947, aux laboratoires Bell, <a href="https://fr.wikipedia.org/wiki/Transistor">Shockley, Bardeen et Brattain</a> inventent le <strong>transistor</strong> au <em>germanium</em> un petit composant électronique qui se comporte comme un interrupteur.  Les transistors, plus petits et dissipant moins de chaleur, vont supplanter les tubes électriques : en 1954 le <em>germanium</em> est remplacé par le <em>silicium</em>, en 1955 apparaissent les premiers ordinateurs entièrement transistorisés, en 1960 le transistor à effet de champ permet l’intégration de dizaines composants dans un centimètre carré. Les transistors sont ensuite directement gravés dans une plaque de <em>silicium</em> constituant un <strong>cicrcuit intégré</strong>. En 1965 Gordon Moore futur directeur d’Intel énonce la <a href="https://fr.wikipedia.org/wiki/Loi_de_Moore">loi empirique</a> portant son nom qui fixe une feuille de route à l’industrie des mircroprocesseurs :  le doublement de la densité d’intégration des transistors tous les deux ans. Cette loi s’est vérifiée jusqu’à présent avec une finesse de gravure d’environ 5 nanomètres en 2020.  Le <a href="https://en.wikipedia.org/wiki/Moore%27s_law#/media/File:Moore's_Law_Transistor_Count_1971-2018.png">graphique</a> ci-dessous représente l’évolution du  nombre de transistors par circuit intégré.</p>

<p>:::center
<img src="images/640px-Moores_Law_Transistor_Count_1971-2018.png" alt="Loi de Moore Source : Wikipedia" />{width=90%}<br />
:::</p>

<h1 id="portes-logiques">Portes logiques</h1>

<h2 id="le-transistor-porte-logique-de-base">Le transistor porte logique de base</h2>

<p>:::definition
Un <strong>transistor</strong> possède trois broches : la grille, la  sortie (ou drain) et la source soumis à des états de tension haute ou basse qu’on peut assimiler aux valeurs binaires 1 et 0 d’un <strong>bit</strong>. Si la tension appliquée sur la grille est haute (bit à  1) alors le transitor laisse passer le courant entre la source d’énergie et la sortie et cette dernière passe à l’état de tension basse (bit à 0), sinon la sortie reste en tension haute (bit  1).</p>

<p>Une <strong>fonction logique</strong> prend un ou plusieurs bits en entrée et retourne un ou plusieurs bits en sortie.  Une <strong>porte logique</strong> est un circuit électronique représentant une <strong>fonction logique</strong>.</p>

<p>Une <strong>table logique</strong>  représente  les sorties produites par une fonction logique pour toutes les entrées possibles.</p>

<p>Un transistor représente une fonction logique dont le bit d’entrée est l’état de tension de la grille  et le bit de sortie, l’état de tension de la sortie. La <strong>table logique</strong>  (table 1) associée est celle du  <strong>NON logique</strong> ou <strong>Inverseur</strong>.</p>

<p>Fichier de test <a href="http://www.cburch.com/logisim/">Logisim</a> : <a href="circuits_logisim/transistor.circ">transistor.circ</a>.
:::</p>

<p>:::center
<img src="images/transistor.png" alt="Transistor" />{width=50%}<br />
:::</p>

<p>Table: <strong>Table logique  d’une porte NON</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">A</th>
      <th>B = NON(A)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td>1</td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p><strong>Il existe deux conventions de représentation symbolique des portes logiques, une européenne et une américaine.</strong></p>

<p>:::{.minipage width=”0.5\linewidth” center=”true”}
<img src="images/porte_not_european.png" alt="porte NOT européeenne" /><br />
&amp;
<img src="images/porte_not_american.png" alt="porte NOT américaine" /><br />
:::</p>

<p><a href="videos/transistor-definition1.mp4">Tutoriel video Logisim  : le transistor</a></p>

<h2 id="dautres-portes-logiques">D’autres portes logiques</h2>

<h3 id="transistors-en-série-ou-en-parallèle">Transistors en série ou en parallèle</h3>

<p>:::exercice
On donne ci-dessous les représentations de deux portes logiques :</p>

<ul>
  <li>La <strong>porte NAND</strong> constituée de deux transistors en série</li>
  <li>La <strong>porte NOR</strong> constituée de deux transistors en parallèle</li>
</ul>

<p>Chacune de  ces portes logiques comportent deux   bits d’entrée : A pour  la grille du transistor 1 et B pour la grille du transistor 2 et un bit de sortie.</p>

<p>Compléter leurs tables logiques.</p>

<p>Vérifier avec <a href="http://www.cburch.com/logisim/">Logisim</a> et les fichiers <a href="circuits_logisim/porte_NAND.circ">porte_NAND.circ</a> et <a href="circuits_logisim/porte_NOR.circ">porte_NOR.circ</a>.</p>

<p><a href="videos/porteNAND.mp4">Tutoriel video Logisim  : porte NAND</a></p>

<p><a href="videos/porteNOR.mp4">Tutoriel video Logisim  : porte NOR</a></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">A</th>
      <th>B</th>
      <th>NAND(A, B)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td>0</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">0</td>
      <td>1</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>0</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>1</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>| A      | B    | NOR(A, B) |
|:——:|——|————|
| 0      | 0    |            |
| 0      | 1    |            |
| 1      | 0    |            |
| 1      | 1    |            |
:::</p>

<p>:::{.minipage width=”0.5\linewidth” center=”true”}
<img src="images/porte_nand.png" alt="Porte NAND" />{width=”80%”}<br />
&amp;
<img src="images/porte_nor.png" alt="Porte NOR" />{width=”80%”}<br />
:::</p>

<p><strong>Voici les  représentations symboliques des  portes logiques NAND et NOR :</strong></p>

<p>:::{.minipage width=”0.5\linewidth” center=”true”}
<img src="images/porte_nand_european.png" alt="Porte NAND européenne" /><br />
&amp;
<img src="images/porte_nand_american.png" alt="Porte NAND américaine" /><br />
:::</p>

<p>:::{.minipage width=”0.5\linewidth” center=”true”}
<img src="images/porte_nor_european.png" alt="Porte NOR européenne" /><br />
&amp;
<img src="images/porte_nor_american.png" alt="Porte NOR américaine" /><br />
:::</p>

<h3 id="portes-logiques-et-fonctions-logiques-élémentaires">Portes logiques et fonctions logiques élémentaires</h3>

<p>:::exercice
Fichier de test <a href="http://www.cburch.com/logisim/">Logisim</a> : <a href="circuits_logisim/exercice2.circ">exercice2.circ</a>.</p>

<ol>
  <li>Compléter la table logique de la porte logique représentée par le circuit ci-dessous. Quelle porte logique peut-on ainsi représenter ?</li>
</ol>

<p><img src="images/porte_not_with_nor.png" alt="Porte NOT" />\</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">A</th>
      <th>B = f(A)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<ol>
  <li>Compléter la table logique de la porte logique représentée par le circuit ci-dessous. Quelle fonction logique correspond à cette porte logique ?</li>
</ol>

<p><img src="images/porte_and_with_nor.png" alt="Porte AND" />{width=60%}\</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">A</th>
      <th>B</th>
      <th>C = g(A, B)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td>0</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">0</td>
      <td>1</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>0</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>1</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p><a href="videos/exercice2.mp4">Tutoriel video Logisim  : exercice 2</a>
:::</p>

<p>:::exercice
Fichier de test <a href="http://www.cburch.com/logisim/">Logisim</a> : <a href="circuits_logisim/exercice3.circ">exercice3.circ</a>.</p>

<ol>
  <li>Compléter la table logique de la porte logique représentée par le circuit ci-dessous. Quelle porte logique peut-on ainsi représenter ?</li>
</ol>

<p><img src="images/porte_not_with_nand.png" alt="Porte NOT" />\</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">A</th>
      <th>B = f(A)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<ol>
  <li>Compléter la table logique de la porte logique représentée par le circuit ci-dessous. Quelle fonction logique correspond à cette porte logique ?</li>
</ol>

<p><img src="images/porte_or_with_nand.png" alt="Porte OR" />{width=60%}\</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">A</th>
      <th>B</th>
      <th>C = g(A, B)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td>0</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">0</td>
      <td>1</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>0</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>1</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p><a href="videos/exercice3.mp4">Tutoriel video Logisim  : exercice 3</a>
:::</p>

<p><strong>Voici les  représentations symboliques des  portes logiques <code class="language-plaintext highlighter-rouge">AND</code> et <code class="language-plaintext highlighter-rouge">OR</code> :</strong></p>

<p>:::{.minipage width=”0.5\linewidth” center=”true”}
<img src="images/porte_and_european.png" alt="Porte AND européenne" /><br />
&amp;
<img src="images/porte_and_american.png" alt="Porte AND américaine" /><br />
:::</p>

<p>:::{.minipage width=”0.5\linewidth” center=”true”}
<img src="images/porte_or_european.png" alt="Porte OR européenne" /><br />
&amp;
<img src="images/porte_or_american.png" alt="Porte OR américaine" /><br />
:::</p>

<p>:::exercice</p>

<ol>
  <li>Construire un circuit représentant une porte <code class="language-plaintext highlighter-rouge">OR</code> uniquement avec des portes <code class="language-plaintext highlighter-rouge">NOR</code>.</li>
  <li>Construire un circuit représentant une porte <code class="language-plaintext highlighter-rouge">AND</code> uniquement avec des portes <code class="language-plaintext highlighter-rouge">NAND</code>.</li>
</ol>

<p>Ainsi chacune des portes, <code class="language-plaintext highlighter-rouge">NAND</code> ou <code class="language-plaintext highlighter-rouge">NOR</code> permet de construire les portes <code class="language-plaintext highlighter-rouge">NOT</code>, <code class="language-plaintext highlighter-rouge">OR</code>, <code class="language-plaintext highlighter-rouge">AND</code>. Toute porte logique  pouvant s’exprimer à l’aide de ces trois portes, les portes <code class="language-plaintext highlighter-rouge">NAND</code> et <code class="language-plaintext highlighter-rouge">NOR</code> sont dites <em>universelles</em>.</p>

<p><a href="videos/exercice4.mp4">Tutoriel video Logisim  : exercice 4</a></p>

<p>:::</p>

<h1 id="fonctions-booléennes">Fonctions booléennes</h1>

<h2 id="fonctions-booléennes-1">Fonctions booléennes</h2>

<p>:::definition</p>

<ul>
  <li>Un <strong>booléen</strong> est un type de données pouvant prendre deux valeurs  <code class="language-plaintext highlighter-rouge">True</code> (Vrai)  ou <code class="language-plaintext highlighter-rouge">False</code> (Faux)  qu’on  représente  numériquement par un <strong>bit</strong> de valeur $1$ pour <code class="language-plaintext highlighter-rouge">True</code> ou $0$ pour <code class="language-plaintext highlighter-rouge">False</code>. Electroniquement, les valeurs 1 et 0 se traduisent  respectivement par des tensions haute ou basse.</li>
  <li>Une <strong>fonction booléenne</strong> $f$ associe un booléen à un ou plusieurs booléens.</li>
  <li>Une <strong>fonction booléenne</strong> avec $n$ arguments est définie sur un ensemble ${0;1}^n$ à $2^n$ valeurs et prend ses valeurs dans ${0;1}$ qui a $2$ éléments. On peut recenser les $2^n$ évaluations  d’une fonction booléenne à $n$ arguments  dans une <strong>table de vérité</strong> qui la  définit entièrement. Il existe $2^{2^n}$ fonctions booléennes à $n$ arguments.</li>
  <li>Une <strong>porte logique</strong> est la représentation sous forme de circuit d’une fonction booléenne et sa <strong>table logique</strong> est la <strong>table de vérité</strong>  de cette fonction.</li>
</ul>

<p>:::</p>

<p>:::exercice</p>

<ol>
  <li>Compléter la  fonction <code class="language-plaintext highlighter-rouge">Python</code> ci-dessous pour qu’elle affiche la table de vérité d’une fonction booléenne à deux entrées. Expliquer le rôle de la fonction <code class="language-plaintext highlighter-rouge">int</code>.</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">table_verite_2bits</span><span class="p">(</span><span class="n">fonction</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'|{:^10}|{:^10}|{:^15}|'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="s">'a'</span><span class="p">,</span><span class="s">'b'</span><span class="p">,</span><span class="n">fonction</span><span class="p">.</span><span class="n">__name__</span><span class="o">+</span><span class="s">'(a,b)'</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">.............:</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="p">.............:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">'|{:^10}|{:^10}|{:^15}|'</span><span class="p">.</span><span class="nb">format</span><span class="p">(......,</span> <span class="p">......,</span> 
            <span class="nb">int</span><span class="p">(</span><span class="n">fonction</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="n">a</span><span class="p">),</span><span class="nb">bool</span><span class="p">(</span><span class="n">b</span><span class="p">)))))</span>
</code></pre></div></div>

<ol>
  <li>Vérifier que  les tables de vérité affichées pour les fonctions <code class="language-plaintext highlighter-rouge">bool.__or__</code>, <code class="language-plaintext highlighter-rouge">bool.__and__</code>  et <code class="language-plaintext highlighter-rouge">bool.__not__</code> sont correctes.</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">In</span> <span class="p">[</span><span class="mi">4</span><span class="p">]:</span> <span class="n">table_verite_2bits</span><span class="p">(</span><span class="nb">bool</span><span class="p">.</span><span class="n">__or__</span><span class="p">)</span>                                                                                                                                           
<span class="o">|</span>    <span class="n">a</span>     <span class="o">|</span>    <span class="n">b</span>     <span class="o">|</span>  <span class="n">__or__</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>  <span class="o">|</span>
<span class="o">|</span>    <span class="mi">1</span>     <span class="o">|</span>    <span class="mi">1</span>     <span class="o">|</span>       <span class="mi">1</span>       <span class="o">|</span>
<span class="o">|</span>    <span class="mi">1</span>     <span class="o">|</span>    <span class="mi">0</span>     <span class="o">|</span>       <span class="mi">1</span>       <span class="o">|</span>
<span class="o">|</span>    <span class="mi">0</span>     <span class="o">|</span>    <span class="mi">1</span>     <span class="o">|</span>       <span class="mi">1</span>       <span class="o">|</span>
<span class="o">|</span>    <span class="mi">0</span>     <span class="o">|</span>    <span class="mi">0</span>     <span class="o">|</span>       <span class="mi">0</span>       <span class="o">|</span>
</code></pre></div></div>

<p><a href="videos/exercice5.mp4">Tutoriel video : exercice 5</a>
:::</p>

<p>:::propriete</p>

<p>On peut exprimer toute fonction booléenne à l’aide de trois fonctions booléennes élémentaires :</p>

<ul>
  <li>La <em>négation</em> de $x$  est une fonction à 1 bit d’entrée (unaire) notée $\neg x$ ou $\overline{x}$.<br />
Si <code class="language-plaintext highlighter-rouge">x</code> est un booléen, sa <em>négation</em> est <code class="language-plaintext highlighter-rouge">not x</code> en <code class="language-plaintext highlighter-rouge">Python</code>.</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center">$x$</th>
      <th>$\neg x$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<ul>
  <li>La <em>conjonction</em> de $x$ et $y$  est une fonction à 2 bits d’entrée (binaire) notée $x \wedge y$ ou $x . y$.<br />
Si <code class="language-plaintext highlighter-rouge">x</code> et <code class="language-plaintext highlighter-rouge">y</code> sont des booléens, leur  <em>conjonction</em> est <code class="language-plaintext highlighter-rouge">x and y</code> en <code class="language-plaintext highlighter-rouge">Python</code>.</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center">$x$</th>
      <th>$y$</th>
      <th>$x \wedge y$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td>0</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">0</td>
      <td>1</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>0</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>1</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<ul>
  <li>La <em>disconjonction</em> de $x$ et $y$  est une fonction à 2 bits d’entrée (binaire) notée $x \vee y$ ou $x + y$.<br />
Si <code class="language-plaintext highlighter-rouge">x</code> et <code class="language-plaintext highlighter-rouge">y</code> sont des booléens, leur  <em>disjonction</em> est <code class="language-plaintext highlighter-rouge">x or y</code> en <code class="language-plaintext highlighter-rouge">Python</code>.</li>
</ul>

<p>| $x$ | $y$ | $x \vee y$ |
|:—:|—–|————–|
| 0   | 0   |              |
| 0   | 1   |              |  <br />
| 1   | 0   |              | <br />
| 1   | 1   |              |
:::</p>

<p>:::propriete</p>
<ol>
  <li>Les fonctions booléennes élémentaires respectent un certain nombre de règles qui permettent de simplifier les expressions booléennes complexes :</li>
</ol>

<ul>
  <li><em>opérateur involutif</em> :  $\neg(\neg x) = x$ et $\overline{\overline{x}}=x$</li>
  <li><em>élément neutre</em> :   $1 \wedge x = x$ et $1 . x =x$  ou  $0 \vee x = x$ et $0 + x =x$</li>
  <li><em>élément absorbant</em> :   $0 \wedge x = 0$ et $0 . x =0$  ou  $1 \vee x = x$ et $1 + x =1$</li>
  <li><em>idempotence</em> : $x \wedge x = x$ et $x . x =x$  ou  $x \vee x = x$ et $x + x =x$</li>
  <li><em>complément</em> : $x \wedge (\neg x) = 0$ et $x . (\overline{x}) =0$  ou  $x \vee (\neg x) = 1$ et $x + \overline{x} =1$</li>
  <li><em>commutativité</em> :  $x \wedge y = y \wedge x$ et $x . y = y . x$  ou  $x \vee y = y \vee x$ et $x + y = y + x$</li>
  <li><em>associativité</em> :  $x \wedge ( y \wedge z) = (x \wedge  y) \wedge z$ et $x . (y . z) = (x . y) . z$  ou $x \vee ( y \vee z) = (x \vee y) \vee z$ et $x + (y + z) = (x + y) + z$</li>
  <li><em>distributivité</em> :  $x \wedge ( y \vee z)  = (x \wedge  y) \vee (x \wedge z)$ et $x . (y + z) = x . y + x . z$  ou  $x \vee ( y \wedge z)  = (x \vee  y) \wedge (x \vee z)$ et $x + (y . z) = (x + y) . (x + z)$</li>
  <li><em>loi de Morgan</em> : $\neg(x \wedge y) = \neg x \vee \neg y$ et   $\overline{x . y} = \overline{x} + \overline{y}$ ou  $\neg(x \vee y) = \neg x \wedge \neg y$ et   $\overline{x + y} = \overline{x} . \overline{y}$</li>
</ul>

<ol>
  <li>Les fonctions booléennes élémentaire respectent des règles de priorité :  la <em>négation</em> est prioritaire sur la <em>conjonction</em> qui est prioritaire sur la <em>disjonction</em>.<br />
<strong>Il est recommandé de mettre des parenthèses plutôt que d’appliquer les règles de priorité dans l’écriture des expressions booléennes.</strong>
:::</li>
</ol>

<h2 id="qcm-types-e3c">QCM types E3C</h2>

<p>:::exercice</p>

<ol>
  <li>Parmi les quatre expressions suivantes, laquelle s’évalue en True ?</li>
</ol>

<ul>
  <li>
    <p><strong>Réponse A :</strong>  <code class="language-plaintext highlighter-rouge">False and (True and False)</code></p>
  </li>
  <li>
    <p><strong>Réponse B :</strong>   <code class="language-plaintext highlighter-rouge">False or (True and False)</code></p>
  </li>
  <li>
    <p><strong>Réponse B :</strong>  <code class="language-plaintext highlighter-rouge">True and (True and False)</code></p>
  </li>
  <li>
    <p><strong>Réponse C :</strong>  <code class="language-plaintext highlighter-rouge">True or (True and False)</code></p>
  </li>
</ul>

<ol>
  <li>Sachant que l’expression <code class="language-plaintext highlighter-rouge">not(a or b)</code> a la valeur <code class="language-plaintext highlighter-rouge">True</code>, quelles peuvent
être les valeurs des variables booléennes a et b ?</li>
</ol>

<ul>
  <li><strong>Réponse A :</strong> <code class="language-plaintext highlighter-rouge">True</code> et <code class="language-plaintext highlighter-rouge">True</code></li>
  <li><strong>Réponse B :</strong> <code class="language-plaintext highlighter-rouge">False</code> et <code class="language-plaintext highlighter-rouge">True</code></li>
  <li><strong>Réponse C :</strong> <code class="language-plaintext highlighter-rouge">True</code> et <code class="language-plaintext highlighter-rouge">False</code></li>
  <li><strong>Réponse D :</strong> <code class="language-plaintext highlighter-rouge">False</code> et <code class="language-plaintext highlighter-rouge">False</code></li>
</ul>

<ol>
  <li>Pour quelles valeurs booléennes des variables <code class="language-plaintext highlighter-rouge">a, b</code> et <code class="language-plaintext highlighter-rouge">c</code> l’expression <code class="language-plaintext highlighter-rouge">(a or b) and (not c)</code> a-t-elle pour valeur <code class="language-plaintext highlighter-rouge">True</code></li>
</ol>

<ul>
  <li><strong>Réponse A :</strong> <code class="language-plaintext highlighter-rouge">a  = True b = False c = True</code></li>
  <li><strong>Réponse B :</strong> <code class="language-plaintext highlighter-rouge">a  = True b = False c = False</code></li>
  <li><strong>Réponse C :</strong> <code class="language-plaintext highlighter-rouge">a  = False b = False c = True</code></li>
  <li><strong>Réponse D :</strong> <code class="language-plaintext highlighter-rouge">a  = False b = True  c = True</code></li>
</ul>

<ol>
  <li>Si A et B sont des variables booléennes, laquelle de ces expressions booléennes est équivalente<br />
à <code class="language-plaintext highlighter-rouge">(not A) or B</code> ?</li>
</ol>

<ul>
  <li><strong>Réponse A :</strong> <code class="language-plaintext highlighter-rouge">(A and B) or (not A and B)</code></li>
  <li><strong>Réponse B :</strong> <code class="language-plaintext highlighter-rouge">(A and B) or (not A and B) or (not A and not B)</code></li>
  <li><strong>Réponse C :</strong> <code class="language-plaintext highlighter-rouge">(not A and B) or (not A and not B)</code></li>
  <li><strong>Réponse D :</strong> <code class="language-plaintext highlighter-rouge">(A and B) or (not A and not B)</code></li>
</ul>

<ol>
  <li>Choisir une expression booléenne pour la variable S qui satisfait la
table de vérité suivante.</li>
</ol>

<p>A   B   S
  — — —
  0   0   1
  0   1   0
  1   0   1
  1   1   1</p>

<ul>
  <li><strong>Réponse A :</strong>  A ou (non B)</li>
  <li><strong>Réponse B :</strong> (non A) ou B</li>
  <li><strong>Réponse C :</strong> (non A) ou (non B)</li>
  <li><strong>Réponse D :</strong> non (A ou B)</li>
</ul>

<ol>
  <li>On considère une formule booléenne form des variables booléennes <code class="language-plaintext highlighter-rouge">a</code> et <code class="language-plaintext highlighter-rouge">b</code> dont voici la table de vérité.</li>
</ol>

<p>a     b      form
—   —-   —-
True  True   False 
False True   False 
True  False  True 
False False  False</p>

<p>Quelle est cette formule booléenne  ?</p>

<ul>
  <li><strong>Réponse A :</strong>  <code class="language-plaintext highlighter-rouge">a and b</code></li>
  <li><strong>Réponse B :</strong> <code class="language-plaintext highlighter-rouge">a or b</code></li>
  <li><strong>Réponse C :</strong> <code class="language-plaintext highlighter-rouge">a and not(b)</code></li>
  <li><strong>Réponse D :</strong> <code class="language-plaintext highlighter-rouge">not(a) or b</code></li>
</ul>

<p><a href="videos/exercice6.mp4">Tutoriel video  : exercice 6</a></p>

<p>:::</p>

<h2 id="pour-aller-plus-loin-hors-programme-de-première-nsi">Pour aller plus loin (hors programme de première NSI)</h2>

<h3 id="dresser-la-table-de-vérité-dune-fonction-booléenne">Dresser la table de vérité d’une fonction booléenne</h3>

<p>:::exercice
Démontrer dans chaque cas l’égalité des expressions booléennes en utilisant les deux méthodes suivantes :</p>

<ul>
  <li>
    <p><strong>Méthode 1</strong> : en comparant les tables de vérité des deux expressions booléennes ;</p>
  </li>
  <li>
    <p><strong>Méthode 2</strong> : en utilisant les règles de simplification de la propriété 2.</p>
  </li>
</ul>

<ol>
  <li>$x + x . y = x$</li>
  <li>$x + \overline{x} . y= x + y$</li>
  <li>$x . z + \overline{x} . y + y . z = x . z + \overline{x} . y$</li>
  <li>$\overline{y . (x + \overline{y})} = \overline{x} + \overline{y}$</li>
  <li>$x . ( \overline{x} + \overline{y}) . (x + y) = x . \overline{y}$</li>
</ol>

<p>:::</p>

<h3 id="exprimer-une-fonction-booléenne-à-partir-de-sa-table-de-vérité">Exprimer une fonction booléenne à partir de sa table de vérité</h3>

<p>:::exercice
On considère la fonction booléenne dont la table de vérité est :</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">$x$</th>
      <th>$y$</th>
      <th>$f(x, y)$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td style="text-align: center">0</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<ol>
  <li>Exprimer chacune des lignes où la fonction prend la valeur $1$ comme la <em>conjonction</em> des entrées en remplaçant chaque $1$ par la variable qu’il représente et chaque $0$ par la négation de la variable. Par exemple le $1$ de la deuxième ligne s’écrira $\overline{x} . y$.</li>
  <li>On peut alors écrire $f(x,y)$ comme la <em>disjonction</em> des <em>formes conjonctives</em> obtenues à la question précédente. En déduire une expression booléenne de $f(x, y)$.</li>
  <li>Ouvrir le logiciel <a href="http://www.cburch.com/logisim/">Logisim</a> et construire une porte logique représentant cette fonction booléenne.</li>
  <li>Cette fonction s’appelle <code class="language-plaintext highlighter-rouge">OU EXCLUSIF</code> ou <code class="language-plaintext highlighter-rouge">XOR</code>. Ce nom vous paraît-il bien choisi ?</li>
</ol>

<p>:::</p>

<p><strong>Voici les  représentations symboliques de la  porte logique <code class="language-plaintext highlighter-rouge">XOR</code> :</strong></p>

<p>:::{.minipage width=”0.5\linewidth” center=”true”}
<img src="images/porte_xor_european.png" alt="Porte XOR europeenne" /><br />
&amp;
<img src="images/porte_xor_american.png" alt="Porte XOR americaine" /><br />
:::</p>

<h1 id="circuits-combinatoires">Circuits combinatoires</h1>

<h2 id="définition">Définition</h2>

<p>:::definition
Un <strong>circuit logique combinatoire</strong> permet de réaliser une ou plusieurs fonctions booléennes : ses sorties ne dépendent que de l’état actuel de ses entrées. Les portes logiques <code class="language-plaintext highlighter-rouge">NOT</code>, <code class="language-plaintext highlighter-rouge">NOR</code>, <code class="language-plaintext highlighter-rouge">NAND</code>, <code class="language-plaintext highlighter-rouge">AND</code>, <code class="language-plaintext highlighter-rouge">OR</code> et <code class="language-plaintext highlighter-rouge">XOR</code> sont des circuits combinatoires.</p>

<p>Il existe d’autres circuits, dits séquentiels, dont les sorties se calculent non seulement à partir de leurs  valeurs d’entrée actuelles mais aussi à partir de leurs états précédents : le facteur temps intervient. Ils utilisent des circuits de mémoire pour mémoriser leurs états antérieurs.
:::</p>

<p>:::exercice</p>

<p>On considère la fonction booléeenne $f$ dont la table de vérité est donnée ci-dessous :</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">$x$</th>
      <th>$y$</th>
      <th>$f(x, y)$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <td style="text-align: center">0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>1</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<ol>
  <li>En utilisant la méthode exposée dans l’exercice 8, déterminer une expression booléenne de la fonction $f$.</li>
  <li>
    <p>Ouvrir le logiciel <a href="http://www.cburch.com/logisim/">Logisim</a> et construire un circuit combinatoire  représentant cette fonction booléenne :</p>

    <ul>
      <li>En utilisant les portes logiques <code class="language-plaintext highlighter-rouge">NOT</code>, <code class="language-plaintext highlighter-rouge">NOR</code>, <code class="language-plaintext highlighter-rouge">NAND</code>, <code class="language-plaintext highlighter-rouge">AND</code>, <code class="language-plaintext highlighter-rouge">OR</code> ou <code class="language-plaintext highlighter-rouge">XOR</code>.</li>
      <li>En n’utilisant que des portes logiques <code class="language-plaintext highlighter-rouge">NOT</code>, <code class="language-plaintext highlighter-rouge">AND</code> ou  <code class="language-plaintext highlighter-rouge">OR</code>.</li>
      <li>En n’utilisant que des portes logiques  <code class="language-plaintext highlighter-rouge">NOR</code>.</li>
    </ul>
  </li>
</ol>

<p><a href="videos/exercice9.mp4">Tutoriel video  : exercice 9</a></p>

<p>:::</p>

<h2 id="décodeur-avec-2-bits-dentrées">Décodeur avec 2 bits d’entrées</h2>

<p>:::exercice</p>

<p>On considère un circuit combinatoire qui  possède deux entrées $e_{0}$ et $e_{1}$ et quatre sorties $s_{0}$, $s_{1}$, $s_{2}$ et $s_{3}$.</p>

<p>La sortie indexée par le nombre dont le bit de poids faible est $e_{0}$ et le bit de poids fort $e_{1}$, est positionnée à $1$ et les autres sorties à $0$. Ce circuit est ainsi appelé <strong>décodeur $2$ bits</strong>.</p>

<ol>
  <li>Compléter la table de vérité de ce circuit combinatoire.</li>
</ol>

<table>
  <thead>
    <tr>
      <th style="text-align: center">$e_{0}$</th>
      <th>$e_{1}$</th>
      <th>$s_{0}$</th>
      <th>$s_{1}$</th>
      <th>$s_{2}$</th>
      <th>$s_{3}$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td>0</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">0</td>
      <td>1</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>0</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>1</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<ol>
  <li>
    <p>En utilisant la méthode exposée dans l’exercice 7, déterminer une expression booléenne de chacune des sorties $s_{0}$, $s_{1}$, $s_{2}$ et $s_{3}$, en fonction des entrées $e_{0}$ et $e_{1}$.</p>
  </li>
  <li>
    <p>Ouvrir le logiciel <a href="http://www.cburch.com/logisim/">Logisim</a> et construire un circuit combinatoire  représentant un <strong>décodeur $2$ bits</strong>.
:::</p>
  </li>
</ol>

<h2 id="demi-additionneur-et-additionneur--1-bit">Demi-additionneur et additionneur  1 bit</h2>

<p>:::exercice</p>

<ol>
  <li>
    <p>Effectuer les additions binaires : $0+0$, $0+1$, $1+0$ et $1+1$.</p>
  </li>
  <li>
    <p>Un <strong>demi-additionneur binaire 1 bit</strong>  est  un circuit combinatoire qui  possède :</p>

    <ul>
      <li>deux entrées : deux bits d’opérande $e_{0}$ et $e_{1}$ ;</li>
      <li>deux sorties : un bit de résultat  $s$ et un bit de retenue  sortante $r$.</li>
    </ul>
  </li>
</ol>

<p>La sortie $s$ prend pour valeur le bit des unités et la sortie $r$ le bit de retenue sortante, lorsqu’on additionne les deux bits d’entrée $e_{0}$ et $e_{1}$.</p>

<ol>
  <li>Compléter la table de vérité de ce circuit combinatoire :</li>
</ol>

<table>
  <thead>
    <tr>
      <th style="text-align: center">$e_{0}$</th>
      <th>$e_{1}$</th>
      <th>$s$</th>
      <th>$r$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td>0</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">0</td>
      <td>1</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>0</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td>1</td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<ol>
  <li>Justifier qu’un <strong>demi-additionneur binaire 1 bit</strong>  peut être représenté par le circuit ci-dessous.</li>
</ol>

<p><img src="images/demi_additionneur.png" alt="Demi-additionneur binaire" />{width=”50%”}\</p>

<ol>
  <li>Ouvrir le logiciel <a href="http://www.cburch.com/logisim/">Logisim</a> et construire un circuit combinatoire  représentant un <strong>demi-additionneur binaire 1 bit</strong>.</li>
</ol>

<p><a href="videos/exercice11.mp4">Tutoriel video  : exercice 11</a>
:::</p>

<p>:::exercice</p>

<p>Un <strong>additionneur binaire   1 bit</strong> est  un circuit combinatoire qui  possède :</p>

<ul>
  <li>trois entrées : deux bits d’opérande $e_{0}$ et $e_{1}$ et un bit de retenue entrante $r_{0}$</li>
  <li>deux bits de sortie : un bit de résultat  $s_{2}$ et un bit de retenue  sortante $r_{3}$.</li>
</ul>

<ol>
  <li>Compléter les colonnes de la table de vérité d’un <strong>additionneur binaire   1 bit</strong>  pour le bit de résultat $s_{2}$ et le bit  retenue  sortante $r_{3}$.</li>
</ol>

<p>| $e_{0}$ | $e_{1}$ | $r_{0}$ | $s_{1}=\ldots \ldots$ | $r_{1}=\ldots \ldots$ | $s_{2}=\ldots \ldots$ | $r_{2}=\ldots \ldots$ |  $r_{3}=\ldots \ldots$ |
|:——-:|———|———|—————————|———————–|—————————|———————–|————————|
| 0       | 0       | 0       |                           |                       |                           |                       |                        |
| 0       | 1       | 0       |                           |                       |                           |                       |                        |
| 1       | 0       | 0       |                           |                       |                           |                       |                        |
| 1       | 1       | 0       |                           |                       |                           |                       |                        |
| 0       | 0       | 1       |                           |                       |                           |                       |                        |
| 0       | 1       | 1       |                           |                       |                           |                       |                        |
| 1       | 0       | 1       |                           |                       |                           |                       |                        |
| 1       | 1       | 1       |                           |                       |                           |                       |                        |</p>
<ol>
  <li>
    <p>Un <strong>additionneur binaire   1 bit</strong> peut être réalisé à l’aide de deux <strong>demi-additionneurs binaires 1 bit</strong> :</p>

    <ul>
      <li>Le premier <strong>demi-additionneur binaire 1 bit</strong> prend en entrée les bits d’opérande $e_{0}$ et $e_{1}$ et retourne en sortie un bit de résultat intermédiaire $s_{1}$ et un bit de retenue sortante intermédiaire $r_{1}$. Donner une expression booléenne de $s_{1}$ et $r_{1}$ en fonction de $e_{0}$ et $e_{1}$.</li>
      <li>Le second <strong>demi-additionneur binaire 1 bit</strong> prend en entrée le bit de résultat $s_{1}$ et le bit de retenue entrante $r_{0}$ et retourne en sortie le bit de résultat  final $s_{2}$ et un bit de retenue sortante intermédiaire $r_{2}$. Donner une expression booléenne de $s_{2}$ et $r_{2}$ en fonction de $s_{1}$ et $r_{0}$.</li>
      <li>Enfin, la retenue sortante $r_{3}$ s’obtient à partir  de la retenue sortante $r_{1}$ du premier demi-additionneur et de la retenue sortante $r_{2}$ du second. Donner une expression booléenne de $r_{3}$ en fonction de $r_{1}$ et $r_{2}$.</li>
    </ul>

    <p>Compléter les colonnes $s_{1}$, $r_{1}$ et $r_{2}$ puis $s_{2}$ et $r_{3}$ de la table de vérité de l’<strong>additionneur binaire à  1 bit</strong>.</p>
  </li>
  <li>
    <p>Avec le logiciel <a href="http://www.cburch.com/logisim/">Logisim</a> ouvrir le fichier contenant le demi-additionneur de l’exercice précédent.</p>
    <ul>
      <li>Ajouter un nouveau circuit avec <code class="language-plaintext highlighter-rouge">Add a circuit</code> , le nommer <code class="language-plaintext highlighter-rouge">additionneur1bit</code> puis copier/coller dedans le circuit du <strong>demi-additionneur binaire 1 bit</strong>. Compléter le  circuit  pour obtenir  un <strong>additionneur binaire 1 bit</strong>.</li>
      <li>Ajouter un nouveau circuit avec <code class="language-plaintext highlighter-rouge">Add a circuit</code> , le nommer <code class="language-plaintext highlighter-rouge">additionneur2bits</code> puis copier/coller dedans le circuit de l’ <strong>additionneur binaire 1 bit</strong>. Compléter le  circuit   pour obtenir  un <strong>additionneur binaire 2 bits</strong>.</li>
    </ul>
  </li>
</ol>

<p><a href="videos/exercice12.mp4">Tutoriel video  : exercice 12</a></p>

<p>:::</p>

<h1 id="opérations-bit-à-bit-en-python-hors-programme-de-première-nsi">Opérations bit à bit en <code class="language-plaintext highlighter-rouge">Python</code> (hors programme de première NSI)</h1>

<p>:::propriete</p>

<p>Les fonctions booléennes élémentaires (<code class="language-plaintext highlighter-rouge">OR</code>, <code class="language-plaintext highlighter-rouge">AND</code>, <code class="language-plaintext highlighter-rouge">NOT</code>, <code class="language-plaintext highlighter-rouge">XOR</code>) existent en <code class="language-plaintext highlighter-rouge">Python</code> sous la forme d’opérateurs booléens mais sont également implémentés sous la forme d’opérateurs bit à bit sur les nombres. Un <em>opérateur bit  à bit</em> (<em>bitwise</em> en anglais) s’applique sur les bits de même poids des  représentations binaires de ses opérandes.</p>

<hr />
<p>Opérateur booléen      Opérateur bit à bit  Exemple                               <br />
———————- ——————-  ——————————————–
<code class="language-plaintext highlighter-rouge">and</code> , ET             <code class="language-plaintext highlighter-rouge">&amp;</code>                  <code class="language-plaintext highlighter-rouge">&gt;&gt;&gt; bin(0b101001 &amp; 0b101010)</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                                        `'0b101000'` 
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">or</code> , OU              <code class="language-plaintext highlighter-rouge">|</code>                  <code class="language-plaintext highlighter-rouge">&gt;&gt;&gt; bin(0b101001 | 0b101010)</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                                        `'0b101011'` 
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">xor</code> , OU EXCLUSIF    <code class="language-plaintext highlighter-rouge">^</code>                  <code class="language-plaintext highlighter-rouge">&gt;&gt;&gt; bin(0b101001 ^ 0b101010)</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                                        `'0b000011'` 
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">not</code> ,  NEGATION      <code class="language-plaintext highlighter-rouge">~</code>                  <code class="language-plaintext highlighter-rouge">&gt;&gt;&gt; ~5 #~x retourne -x - 1</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                                        `-6`
</code></pre></div></div>

<hr />
<p>:::</p>

<p>Exemples d’utilisation d’opérateurs bit à bit :</p>

<ul>
  <li>On  peut utiliser le <code class="language-plaintext highlighter-rouge">ET</code> bit à bit pour sélectionner uniquement certains bits, par exemple les bits de rang pairs :</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">bits_pairs</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">bin</span><span class="p">(</span><span class="n">bits_pairs</span><span class="p">)</span>
<span class="s">'0b1010101'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">bin</span><span class="p">(</span><span class="mi">183</span><span class="p">)</span>
<span class="s">'0b10110111'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">bin</span><span class="p">(</span><span class="mi">183</span> <span class="o">&amp;</span> <span class="n">bits_pairs</span><span class="p">)</span>
<span class="s">'0b10100010'</span>
</code></pre></div></div>

<ul>
  <li>Le <code class="language-plaintext highlighter-rouge">OU EXCLUSIF</code> peut servir à masquer / démasquer une partie de la représentation binaire d’un nombre (on peut l’employer avec tout objet codé numériquement comme une image ou un caractère).</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">diego</span> <span class="o">=</span> <span class="mi">69</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">masque</span> <span class="o">=</span> <span class="mi">42</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">zorro</span> <span class="o">=</span> <span class="n">diego</span> <span class="o">^</span> <span class="n">masque</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">zorro</span>
<span class="mi">111</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">zorro</span> <span class="o">^</span> <span class="n">masque</span>
<span class="mi">69</span>
</code></pre></div></div>
<p>:::exercice</p>

<p>Dans un réseau <code class="language-plaintext highlighter-rouge">IP</code> l’adresse <code class="language-plaintext highlighter-rouge">IP</code> d’une machine est constituée d’un préfixe correspondant à l’adresse du réseau (commune à toutes les machines du réseau) et à un suffixe machine, identifiant la machine sur le réseau.</p>

<p>Le préfixe réseau s’obtient à partir de l’adresse <code class="language-plaintext highlighter-rouge">IP</code> de la  machine en faisant un <code class="language-plaintext highlighter-rouge">ET</code> bit à bit avec le masque de sous-réseau.</p>

<p>Par exemple si l’adresse est  <code class="language-plaintext highlighter-rouge">192.168.11.12</code>  de représentation binaire <code class="language-plaintext highlighter-rouge">11000000.10101000.00001011.00001011</code> et le masque de sous-réseau est <code class="language-plaintext highlighter-rouge">255.255.252.0</code> de représentation binaire</p>

<p><code class="language-plaintext highlighter-rouge">11111111.11111111.11111100.00000000</code> alors le préfixe réseau est <code class="language-plaintext highlighter-rouge">11000000.10101000.00001000.00000000</code>  soit <code class="language-plaintext highlighter-rouge">192.168.8.0</code>.</p>

<p>On donne ci-dessous deux fonctions outils :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">ip2liste</span><span class="p">(</span><span class="n">ip</span><span class="p">):</span>
    <span class="s">"Transforme une  adresse IP V4 (type str) en liste d'entiers"</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">champ</span><span class="p">)</span> <span class="k">for</span> <span class="n">champ</span> <span class="ow">in</span> <span class="n">ip</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">'.'</span><span class="p">)]</span>

<span class="k">def</span> <span class="nf">liste2ip</span><span class="p">(</span><span class="n">ipliste</span><span class="p">):</span>
    <span class="s">"Transforme une  liste d'entiers en adresse IP V4 (type str)"</span>
    <span class="k">return</span> <span class="s">'.'</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ipliste</span><span class="p">)</span>
</code></pre></div></div>

<ol>
  <li>
    <p>Écrire une fonction de signature <code class="language-plaintext highlighter-rouge">prefixe_reseau(ip, masque)</code> qui retourne le préfixe réseau sous forme d’adresse IP V4 (type <code class="language-plaintext highlighter-rouge">str</code>) à partir d’une adresse IP V4 et d’un masque de sous-réseau.</p>
  </li>
  <li>
    <p>Écrire une fonction de signature <code class="language-plaintext highlighter-rouge">suffixe_machine(ip, masque)</code> qui retourne le suffixe machine sous forme d’adresse IP V4 (type <code class="language-plaintext highlighter-rouge">str</code>) à partir d’une adresse IP V4 et d’un masque de sous-réseau.</p>
  </li>
</ol>

<p>Voici un exemple de résultat attendu :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">prefixe_reseau</span><span class="p">(</span><span class="s">'145.245.11.254'</span><span class="p">,</span><span class="s">'255.255.252.0'</span><span class="p">)</span>
<span class="s">'145.245.8.0'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">suffixe_machine</span><span class="p">(</span><span class="s">'145.245.11.254'</span><span class="p">,</span><span class="s">'255.255.252.0'</span><span class="p">)</span>
<span class="s">'0.0.3.254'</span>
</code></pre></div></div>

<p>:::</p>

<p>:::propriete</p>

<p><code class="language-plaintext highlighter-rouge">Python</code> définit également des opérateurs sur les bits d’un nombre, plus efficaces que les opérations mathématiques équivalentes :</p>

<ul>
  <li>
    <p>Le décalage de <code class="language-plaintext highlighter-rouge">nombre</code> de  <code class="language-plaintext highlighter-rouge">n</code> bits vers la gauche multiplie <code class="language-plaintext highlighter-rouge">nombre</code> par $2^{n}$ et s’écrit  <code class="language-plaintext highlighter-rouge">nombre &lt;&lt; n</code>.</p>
  </li>
  <li>
    <p>Le décalage de <code class="language-plaintext highlighter-rouge">nombre</code> de  <code class="language-plaintext highlighter-rouge">n</code> bits vers la droite divise <code class="language-plaintext highlighter-rouge">nombre</code> par $2^{n}$ et s’écrit  <code class="language-plaintext highlighter-rouge">nombre &gt;&gt; n</code>.</p>
  </li>
</ul>

<p>:::</p>

<p>:::exercice
Dans l’algorithme de recherche dichotomique, après  division en deux de  la zone de recherche, l’algorithme  s’appelle lui-même sur l’une des deux moitiés. C’est un algorithme de type <em>Diviser pour régner</em> qui peut se programmer récursivement comme nous le verrons en terminale dans le chapitre sur la récursivité.</p>

<p>Si on note   <em>n</em> la taille de la liste, une autre implémentation, non récursive, est la suivante :</p>

<ul>
  <li>on commence la recherche au début de la liste et on avance avec un pas <code class="language-plaintext highlighter-rouge">pas = n // 2</code>   ou <code class="language-plaintext highlighter-rouge">pas = n &gt;&gt; 1</code> jusqu’au premier élément supérieur à l’élément cherché ;</li>
  <li>
    <p>on repart de l’élément précédent le point d’arrêt  et on avance désormais avec un pas divisé par 2 soit :</p>

    <p><code class="language-plaintext highlighter-rouge">pas = pas &gt;&gt; 1</code> ;</p>
  </li>
  <li>on répète en boucle ces instructions jusqu’à ce que le pas atteigne $1$.</li>
</ul>

<p>A la fin de de la boucle, on détermine si l’élément précédent le dernier point d’arrêt est l’élément recherché.</p>

<p>Compléter le code de la fonction <code class="language-plaintext highlighter-rouge">recherche_dicho2</code> qui implémente cet algorithme.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">recherche_dicho2</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">n</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
    <span class="n">pas</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">pas</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">x</span> <span class="o">+</span> <span class="n">pas</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="p">.................:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">..............</span>
        <span class="n">pas</span> <span class="o">=</span> <span class="p">................</span>
    <span class="k">return</span> <span class="p">............</span>
</code></pre></div></div>

<p>:::</p>
